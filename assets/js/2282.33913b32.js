(self.webpackChunkblog=self.webpackChunkblog||[]).push([[2282],{2282:e=>{async function t(e,t,s,o){try{postMessage({type:"progress",stage:"frequencies_start",message:"Computing vibrational frequencies..."});const s=o.AOBasis.load(e.atoms(),t.basisSet);let l,n,i;if("hf"===t.method){const e=new o.HartreeFock(s);l=new o.HartreeFockSCF(e),l.setChargeMultiplicity(t.charge||0,t.multiplicity||1);await l.run();n=l.wavefunction(),i=e.hessianEvaluator()}else if(t.method.startsWith("dft-")){const e=t.method.substring(4),a=new o.DFT(e,s);l=a.scf(o.SpinorbitalKind.Restricted),l.setChargeMultiplicity(t.charge||0,t.multiplicity||1);await l.run();n=l.wavefunction(),i=a.hessianEvaluator()}i.setStepSize(t.hessianStepSize||.005),i.setUseAcousticSumRule(!0),postMessage({type:"log",level:2,message:`Computing Hessian with step size ${i.stepSize()} Bohr...`});const r=i.compute(n.molecularOrbitals);postMessage({type:"log",level:2,message:`Hessian computed: ${r.rows()}x${r.cols()}`});const c=o.computeVibrationalModesFromMolecule(r,e,!1),g=c.getAllFrequencies(),m=[];for(let e=0;e<g.size();e++)m.push(g.get(e));let p=[];try{const e=c.normalModes;if(e){const t=e.rows(),s=e.cols();postMessage({type:"log",level:2,message:`Normal modes matrix: ${t}x${s}`});for(let o=0;o<s;o++){const s=[];for(let a=0;a<t;a++)s.push(e.get(a,o));p.push(s)}postMessage({type:"log",level:2,message:`Extracted ${p.length} normal mode vectors`})}else postMessage({type:"log",level:3,message:"Normal modes matrix is null or undefined"})}catch(a){postMessage({type:"log",level:3,message:`Could not extract normal mode vectors: ${a.message}`})}const u=c.summaryString();return postMessage({type:"log",level:2,message:`Found ${m.length} vibrational modes`}),{frequencies:m,normalModes:p,nModes:c.nModes(),nAtoms:c.nAtoms(),summary:u}}catch(a){return postMessage({type:"log",level:4,message:`Frequency calculation error: ${a.message}`}),null}}e.exports&&(e.exports={runOptimization:async function(e,s,o){const a=performance.now(),l={energies:[],gradientNorms:[],geometries:[],converged:!1,steps:0,finalEnergy:null,finalMolecule:null};try{postMessage({type:"progress",stage:"optimization_start",message:"Starting geometry optimization..."});const r=await s.moleculeFromXYZ(e.xyzData),c=new o.ConvergenceCriteria;c.gradientMax=e.optGradientMax||1e-4,c.gradientRms=e.optGradientRms||1e-5,c.stepMax=e.optStepMax||.001,c.stepRms=e.optStepRms||1e-4,postMessage({type:"log",level:2,message:`Optimization criteria: gradMax=${c.gradientMax}, gradRms=${c.gradientRms}`});const g=new o.BernyOptimizer(r,c),m=e.optMaxSteps||25;let p=!1;for(let t=0;t<m;t++){postMessage({type:"progress",stage:"optimization_step",message:`Optimization step ${t+1}/${m}...`,step:t+1,maxSteps:m});const s=g.getNextGeometry(),a=o.moleculeToXYZ(s);l.geometries.push(a);const i=o.AOBasis.load(s.atoms(),e.basisSet);let r,c,u,h;if("hf"===e.method){const t=new o.HartreeFock(i);c=new o.HartreeFockSCF(t),c.setChargeMultiplicity(e.charge||0,e.multiplicity||1),u=await c.run();const s=c.wavefunction();h=t.computeGradient(s.molecularOrbitals),r=t}else if(e.method.startsWith("dft-")){const t=e.method.substring(4),s=new o.DFT(t,i);c=s.scf(o.SpinorbitalKind.Restricted),c.setChargeMultiplicity(e.charge||0,e.multiplicity||1),u=await c.run();const a=c.wavefunction();h=s.computeGradient(a.molecularOrbitals),r=s}l.energies.push(u);let f=0;try{f=Math.sqrt(h.squaredNorm())}catch(n){let e=0;const t=h.rows(),s=h.cols();for(let o=0;o<t;o++)for(let t=0;t<s;t++){const s=h.get(o,t);e+=s*s}f=Math.sqrt(e)}if(l.gradientNorms.push(f),postMessage({type:"log",level:2,message:`Step ${t+1}: E = ${u.toFixed(8)} Ha, |grad| = ${f.toFixed(6)}`}),g.update(u,h),g.step()){p=!0,l.converged=!0,l.steps=t+1,postMessage({type:"log",level:2,message:`Optimization converged in ${t+1} steps!`});break}}l.finalMolecule=g.getNextGeometry(),l.finalEnergy=g.currentEnergy();const u=o.moleculeToXYZ(l.finalMolecule);let h=null;try{postMessage({type:"log",level:2,message:"Computing final wavefunction for optimized geometry..."}),h=await async function(e,t,s,o){try{const s=o.AOBasis.load(e.atoms(),t.basisSet);let i,r,c;if("hf"===t.method){const e=new o.HartreeFock(s);r=new o.HartreeFockSCF(e),r.setChargeMultiplicity(t.charge||0,t.multiplicity||1),await r.run(),c=r.wavefunction(),i=e}else if(t.method.startsWith("dft-")){const e=t.method.substring(4),a=new o.DFT(e,s);r=a.scf(o.SpinorbitalKind.Restricted),r.setChargeMultiplicity(t.charge||0,t.multiplicity||1),await r.run(),c=r.wavefunction(),i=a}const g={numBasisFunctions:s.nbf(),numAtoms:e.size(),nAlpha:c.nAlpha||Math.ceil(e.numElectrons()/2),nBeta:c.nBeta||Math.floor(e.numElectrons()/2),numElectrons:e.numElectrons(),basisSet:t.basisSet,method:t.method};let m=[],p=[];try{const t=c.orbitalEnergies();for(let e=0;e<t.size();e++)m.push(t.get(e));const s=m.length;if(s>0){const t=c.nAlpha||Math.ceil(e.numElectrons()/2),o=c.nBeta||Math.floor(e.numElectrons()/2);for(let e=0;e<s;e++)e<Math.min(t,o)?p.push(2):e<Math.max(t,o)?p.push(1):p.push(0)}}catch(a){postMessage({type:"log",level:3,message:`Could not extract orbital data: ${a.message}`})}try{const e=c.exportToString("fchk");e&&e.length>0&&(g.fchk=e)}catch(l){postMessage({type:"log",level:3,message:`Could not generate FCHK file for optimized geometry: ${l.message}`})}let u=null;try{if(m.length>0&&p.length>0){let e=-1,t=-1;for(let s=0;s<p.length;s++)if(p[s]>0)e=s;else if(-1===t&&0===p[s]){t=s;break}if(e>=0){const s=m[e];if(u={homo:s},t>=0){const e=m[t];u.lumo=e,u.gap=e-s}}}}catch(a){postMessage({type:"log",level:3,message:`Could not calculate molecular properties: ${a.message}`})}let h={};try{const e=e=>{const t=e.rows(),s=e.cols(),o=[];for(let a=0;a<t;a++){const t=[];for(let o=0;o<s;o++)t.push(e.get(a,o));o.push(t)}return{rows:t,cols:s,data:o}};try{const t=i.overlapMatrix();h.overlap=e(t)}catch(n){postMessage({type:"log",level:3,message:`Could not compute overlap matrix: ${n.message}`})}try{const t=i.kineticMatrix();h.kinetic=e(t)}catch(n){postMessage({type:"log",level:3,message:`Could not compute kinetic matrix: ${n.message}`})}try{const t=i.nuclearAttractionMatrix();h.nuclear=e(t)}catch(n){postMessage({type:"log",level:3,message:`Could not compute nuclear attraction matrix: ${n.message}`})}try{const t=i.fockMatrix(c.molecularOrbitals);h.fock=e(t)}catch(n){postMessage({type:"log",level:3,message:`Could not compute Fock matrix: ${n.message}`})}try{const t=c.molecularOrbitals.densityMatrix;h.density=e(t)}catch(n){postMessage({type:"log",level:3,message:`Could not compute density matrix: ${n.message}`})}try{const t=c.coefficients();h.coefficients=e(t)}catch(n){postMessage({type:"log",level:3,message:`Could not extract MO coefficients: ${n.message}`})}}catch(a){postMessage({type:"log",level:3,message:`Matrix computation failed: ${a.message}`})}return{wavefunctionData:g,orbitalEnergies:m,orbitalOccupations:p,properties:u,matrices:h,molecule:e,basis:s,wavefunction:c,method:i}}catch(a){throw postMessage({type:"log",level:4,message:`Final wavefunction calculation error: ${a.message}`}),a}}(l.finalMolecule,e,0,o)}catch(i){postMessage({type:"log",level:3,message:`Warning: Could not compute final wavefunction: ${i.message}`})}let f=null;return e.computeFrequencies&&p&&(f=await t(l.finalMolecule,e,0,o)),{success:!0,optimization:l,finalXYZ:u,finalWavefunctionData:h,frequencies:f,elapsedMs:performance.now()-a}}catch(i){throw postMessage({type:"log",level:4,message:`Optimization error: ${i.message}`}),i}},computeFrequencies:t})}}]);
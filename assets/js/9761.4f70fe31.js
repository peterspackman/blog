(()=>{var e,t,a,s,o,r,n={},i={};function l(e){var t=i[e];if(void 0!==t)return t.exports;var a=i[e]={exports:{}};return n[e](a,a.exports,l),a.exports}l.m=n,e="function"==typeof Symbol?Symbol("webpack queues"):"__webpack_queues__",t="function"==typeof Symbol?Symbol("webpack exports"):"__webpack_exports__",a="function"==typeof Symbol?Symbol("webpack error"):"__webpack_error__",s=e=>{e&&e.d<1&&(e.d=1,e.forEach((e=>e.r--)),e.forEach((e=>e.r--?e.r++:e())))},l.a=(o,r,n)=>{var i;n&&((i=[]).d=-1);var l,c,u,p=new Set,g=o.exports,f=new Promise(((e,t)=>{u=t,c=e}));f[t]=g,f[e]=e=>(i&&e(i),p.forEach(e),f.catch((e=>{}))),o.exports=f,r((o=>{var r;l=(o=>o.map((o=>{if(null!==o&&"object"==typeof o){if(o[e])return o;if(o.then){var r=[];r.d=0,o.then((e=>{n[t]=e,s(r)}),(e=>{n[a]=e,s(r)}));var n={};return n[e]=e=>e(r),n}}var i={};return i[e]=e=>{},i[t]=o,i})))(o);var n=()=>l.map((e=>{if(e[a])throw e[a];return e[t]})),c=new Promise((t=>{(r=()=>t(n)).r=0;var a=e=>e!==i&&!p.has(e)&&(p.add(e),e&&!e.d&&(r.r++,e.push(r)));l.map((t=>t[e](a)))}));return r.r?c:n()}),(e=>(e?u(f[a]=e):c(g),s(i)))),i&&i.d<0&&(i.d=0)},r=Object.getPrototypeOf?e=>Object.getPrototypeOf(e):e=>e.__proto__,l.t=function(e,t){if(1&t&&(e=this(e)),8&t)return e;if("object"==typeof e&&e){if(4&t&&e.__esModule)return e;if(16&t&&"function"==typeof e.then)return e}var a=Object.create(null);l.r(a);var s={};o=o||[null,r({}),r([]),r(r)];for(var n=2&t&&e;"object"==typeof n&&!~o.indexOf(n);n=r(n))Object.getOwnPropertyNames(n).forEach((t=>s[t]=()=>e[t]));return s.default=()=>e,l.d(a,s),a},l.d=(e,t)=>{for(var a in t)l.o(t,a)&&!l.o(e,a)&&Object.defineProperty(e,a,{enumerable:!0,get:t[a]})},l.f={},l.e=e=>Promise.all(Object.keys(l.f).reduce(((t,a)=>(l.f[a](e,t),t)),[])),l.u=e=>"assets/js/"+(4602===e?"em-pthread":e)+"."+{4602:"d4f855a1",7583:"50e6485b",8415:"d38f8669"}[e]+".js",l.miniCssF=e=>{},l.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t),l.r=e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},l.p="/",l.gca=function(e){return e={}[e]||e,l.p+l.u(e)},(()=>{l.b=self.location+"/../../../";var e={9761:1};l.f.i=(t,a)=>{e[t]||importScripts(l.p+l.u(t))};var t=self.webpackChunkblog=self.webpackChunkblog||[],a=t.push.bind(t);t.push=t=>{var s=t[0],o=t[1],r=t[2];for(var n in o)l.o(o,n)&&(l.m[n]=o[n]);for(r&&r(l);s.length;)e[s.pop()]=1;a(t)}})();let c=null,u=null;self.addEventListener("message",(async function(e){const{type:t,data:a}=e.data;try{switch(t){case"init":await async function(){try{postMessage({type:"log",level:2,message:"Initializing OCC in worker..."});try{c=await l.e(8415).then(l.bind(l,8415)),postMessage({type:"log",level:2,message:"Loaded OCC package"})}catch(e){return void postMessage({type:"initialized",success:!1,error:`OCC package import failed: ${e.message}. The WASM module contains Node.js-specific imports that don't work in browsers.`})}u=await c.loadOCC(),u.registerLogCallback&&u.registerLogCallback(((e,t)=>{postMessage({type:"log",level:e,message:t})})),postMessage({type:"initialized",success:!0})}catch(t){postMessage({type:"initialized",success:!1,error:t.message})}}();break;case"analyzeTensor":await async function(t){try{postMessage({type:"log",level:2,message:"Starting elastic tensor analysis..."});const{tensorData:s}=t;let o;o=u.Mat6&&u.Mat6.create?u.Mat6.create(6,6):u.Mat.create(6,6);for(let e=0;e<6;e++)for(let t=0;t<6;t++)o.set(e,t,s[e][t]);const r=new u.ElasticTensor(o),n=[u.AveragingScheme.VOIGT,u.AveragingScheme.REUSS,u.AveragingScheme.HILL],i=["voigt","reuss","hill"],l={bulkModulus:{},shearModulus:{},youngsModulus:{},poissonRatio:{},linearCompressibility:{}};for(let e=0;e<n.length;e++){const t=n[e],a=i[e];l.bulkModulus[a]=r.averageBulkModulus(t),l.shearModulus[a]=r.averageShearModulus(t),l.youngsModulus[a]=r.averageYoungsModulus(t),l.poissonRatio[a]=r.averagePoissonRatio(t),l.linearCompressibility[a]=1e3/l.bulkModulus[a]}let c=null,p=!0,g=null;try{if(!r.eigenvalues||"function"!=typeof r.eigenvalues)throw new Error("eigenvalues() method not available in ElasticTensor");{const e=r.eigenvalues();if(c=[],e&&e.size&&"function"==typeof e.size)for(let t=0;t<e.size();t++)c.push(e.get(t));else if(e&&void 0!==e.length)for(let t=0;t<e.length;t++)c.push(e[t]);else{if(!Array.isArray(e))throw new Error("Unknown eigenvalue result format");c=[...e]}if(c.sort(((e,t)=>e-t)),p=c.every((e=>e>0)),postMessage({type:"log",level:2,message:`Retrieved ${c.length} eigenvalues: [${c.map((e=>e.toFixed(4))).join(", ")}]`}),!p){const e=c.filter((e=>e<=0)).length;postMessage({type:"log",level:1,message:`Warning: Tensor is not positive definite - ${e} eigenvalue(s) <= 0`})}}}catch(a){g=a.message,c=null,p=!0,postMessage({type:"log",level:1,message:`Could not calculate eigenvalues: ${a.message}`})}const f=50,M=[];for(let e=0;e<f;e++)for(let t=0;t<f;t++){const a=e/f*Math.PI,s=t/f*2*Math.PI,o=Math.sin(a)*Math.cos(s),r=Math.sin(a)*Math.sin(s),n=Math.cos(a);M.push(u.Vec3.create(o,r,n))}let m=1/0,y=-1/0,h=1/0,d=-1/0,v=1/0,b=-1/0,x=1/0,w=-1/0;M.forEach((t=>{try{const a=r.youngsModulus(t);m=Math.min(m,a),y=Math.max(y,a);const s=r.linearCompressibility(t);h=Math.min(h,s),d=Math.max(d,s);try{const e=r.shearModulusMinMax(t);e&&(v=Math.min(v,e.min),b=Math.max(b,e.max))}catch(e){const s=a/2.6;v=Math.min(v,s),b=Math.max(b,s)}try{const e=r.poissonRatioMinMax(t);e&&(x=Math.min(x,e.min),w=Math.max(w,e.max))}catch(e){const s=a/(a/3*2)-1;x=Math.min(x,Math.max(-1,s)),w=Math.max(w,Math.min(.5,s))}}catch(e){postMessage({type:"log",level:1,message:`Warning: Could not calculate property for direction: ${e.message}`})}}));const k={shearModulus:{min:v,max:b,anisotropy:b/v},youngsModulus:{min:m,max:y,anisotropy:y/m},poissonRatio:{min:x,max:w,anisotropy:Math.abs(w/x)},linearCompressibility:{min:h,max:d,anisotropy:d/h}},S=[],_=[],R=r.voigtC,C=r.voigtS;for(let e=0;e<6;e++){const t=[],a=[];for(let s=0;s<6;s++)t.push(R.get(e,s)),a.push(C.get(e,s));S.push(t),_.push(a)}postMessage({type:"analysisResult",success:!0,data:{properties:l,eigenvalues:c,eigenvalueError:g,isPositiveDefinite:p,extrema:k,stiffnessMatrix:S,complianceMatrix:_,elasticTensor:r}}),postMessage({type:"log",level:2,message:"Elastic tensor analysis complete"})}catch(a){postMessage({type:"analysisResult",success:!1,error:a.message})}}(a);break;case"generateDirectionalData":await async function(t){try{const{tensorData:a,property:s,plane:o,numPoints:r,isReference:n}=t;let i;postMessage({type:"log",level:2,message:`Generating directional data for ${s} ${o} (ref: ${n})...`}),i=u.Mat6&&u.Mat6.create?u.Mat6.create(6,6):u.Mat.create(6,6);for(let e=0;e<6;e++)for(let t=0;t<6;t++)i.set(e,t,a[e][t]);const l=new u.ElasticTensor(i);if(l.generateDirectionalData)try{const e=l.generateDirectionalData(s,r||180),t=[];for(let a=0;a<e.size();a++){const s=e.get(a);let r=s.x,n=s.y;if("xz"===o){const e=n;n=0,n=e}else if("yz"===o){const e=r;r=n,n=e}t.push({angle:180*s.angle/Math.PI,angleRad:s.angle,value:s.value,valueMin:s.value,valueMax:s.value,x:r,y:n})}return postMessage({type:"directionalDataResult",success:!0,data:t,plane:o,isReference:n||!1}),void postMessage({type:"log",level:2,message:"Directional data generation complete (WASM)"})}catch(e){postMessage({type:"log",level:1,message:`WASM method failed, using fallback: ${e.message}`})}const c=[];for(let t=0;t<=r;t++){const a=t/r*2*Math.PI;let n;n="xy"===o?u.Vec3.create(Math.cos(a),Math.sin(a),0):"xz"===o?u.Vec3.create(Math.cos(a),0,Math.sin(a)):u.Vec3.create(0,Math.cos(a),Math.sin(a));let i=0,p=0,g=0;try{if("youngs"===s)i=l.youngsModulus(n),p=g=i;else if("linear_compressibility"===s)i=l.linearCompressibility(n),p=g=i;else if("shear"===s){const e=l.shearModulusMinMax(n);p=e.min,g=e.max,i=g}else if("poisson"===s){const e=l.poissonRatioMinMax(n);p=e.min,g=e.max,i=g}}catch(e){i=p=g=0}c.push({angle:180*a/Math.PI,angleRad:a,value:i,valueMin:p,valueMax:g})}postMessage({type:"directionalDataResult",success:!0,data:c,plane:o,isReference:n||!1}),postMessage({type:"log",level:2,message:"Directional data generation complete"})}catch(a){postMessage({type:"directionalDataResult",success:!1,error:a.message})}}(a);break;case"generate3DSurfaceData":await async function(t){try{const{tensorData:a,property:s,isReference:o}=t;let r;postMessage({type:"log",level:2,message:`Generating 3D surface data for ${s}...`}),r=u.Mat6&&u.Mat6.create?u.Mat6.create(6,6):u.Mat.create(6,6);for(let e=0;e<6;e++)for(let t=0;t<6;t++)r.set(e,t,a[e][t]);const n=new u.ElasticTensor(r),i=120,l=60,c=[];for(let t=0;t<=i;t++){const a=[];for(let o=0;o<=l;o++){const r=t/i*2*Math.PI,c=o/l*Math.PI,p=Math.sin(c)*Math.cos(r),g=Math.sin(c)*Math.sin(r),f=Math.cos(c),M=u.Vec3.create(p,g,f);let m=0;try{if("youngs"===s)m=n.youngsModulus(M);else if("linear_compressibility"===s)m=n.linearCompressibility(M);else if("shear"===s){const e=n.shearModulusMinMax(M);m=e?e.max:0}else if("poisson"===s){const e=n.poissonRatioMinMax(M);m=e?e.max:0}}catch(e){m=0}a.push(m)}c.push(a)}const p=c.flat(),g=Math.min(...p),f=Math.max(...p);postMessage({type:"3DSurfaceResult",success:!0,data:{surfaceData:c,minValue:g,maxValue:f,property:s,numU:i+1,numV:l+1},isReference:o||!1}),postMessage({type:"log",level:2,message:"3D surface data generation complete"})}catch(a){postMessage({type:"3DSurfaceResult",success:!1,error:a.message})}}(a);break;default:postMessage({type:"error",error:`Unknown message type: ${t}`})}}catch(s){postMessage({type:"error",error:s.message||"Unknown error occurred",stack:s.stack})}}))})();
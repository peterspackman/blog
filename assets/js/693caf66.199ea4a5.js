"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([[3611],{6517:(n,e,o)=>{o.r(e),o.d(e,{default:()=>f});var t=o(1410),a=o(6540),r=o(2111);var l=o(4848);const i=n=>{let{Components:e}=n;const{Canvas:o,OrbitControls:t,THREE:i}=e,[s,f]=(0,a.useState)(0),[_,x]=(0,a.useState)([{n:2,l:1,m:0,weight:1,phase:0,enabled:!0}]),[p,c]=(0,a.useState)(1e-6),[y,u]=(0,a.useState)(0),[m]=(0,a.useState)(6),h=(n,e,o)=>{const t=[..._];if("n"===e){const e=parseInt(o);t[n].n=e,t[n].l>=e&&(t[n].l=e-1,Math.abs(t[n].m)>t[n].l&&(t[n].m=0))}else if("l"===e){const e=parseInt(o);t[n].l=e,Math.abs(t[n].m)>e&&(t[n].m=0)}else"m"===e?t[n].m=parseInt(o):"weight"===e?t[n].weight=parseFloat(o):"phase"===e?t[n].phase=parseFloat(o):"enabled"===e&&(t[n].enabled=o);x(t)},d=()=>{const{camera:n,gl:e,scene:o,size:t}=(0,r.A)(),f=(0,a.useRef)(),x=(0,a.useMemo)((()=>{const n=_.map((n=>({n:n.n,l:n.l,m:n.m,weight:n.enabled?n.weight:0,phase:n.phase})));return new i.ShaderMaterial({uniforms:{time:{value:0},renderMode:{value:s},aspectRatio:{value:1},edgeThreshold:{value:.01},edgeWidth:{value:1e-5},isovalue:{value:p},cameraPos:{value:new i.Vector3},cameraDirection:{value:new i.Vector3},cameraUp:{value:new i.Vector3},cameraRight:{value:new i.Vector3},orbital_n:{value:n.map((n=>n.n))},orbital_l:{value:n.map((n=>n.l))},orbital_m:{value:n.map((n=>n.m))},orbital_weight:{value:n.map((n=>n.weight))},orbital_phase:{value:n.map((n=>n.phase))},orbital_count:{value:_.length}},vertexShader:"\n  varying vec2 vUv;\n\n  void main() {\n    vUv = uv;\n    gl_Position = vec4(position, 1.0); // No projection needed for a screen-filling quad\n  }\n",fragmentShader:"\nprecision highp float;\n\nuniform float time;\nuniform float isovalue;\nuniform float aspectRatio;\nuniform float edgeThreshold;\nuniform float edgeWidth;\nuniform int renderMode;\nuniform vec3 cameraPos;\nuniform vec3 cameraDirection;\nuniform vec3 cameraUp;\nuniform vec3 cameraRight;\n\n// Orbital data arrays - extended to 6 orbitals\nuniform int orbital_n[6];\nuniform int orbital_l[6];\nuniform int orbital_m[6];\nuniform float orbital_weight[6];\nuniform float orbital_phase[6];\nuniform int orbital_count;\n\nvarying vec2 vUv;\n\n#define PI 3.14159265359\n#define MAX_STEPS 100\n#define STEP_SIZE 0.5\n#define DENSITY_THRESHOLD 0.00002\n#define MAX_DISTANCE 100.0\n\n// Maximum L value we'll support\n#define MAX_L 4\n\n// Optimized cartesian calculation of spherical harmonics up to L=4\n// Replace the existing SH computation in your shader with this optimized version\n\n// Constants needed for normalization\n#define SQRT_PI 1.77245385091\n#define SQRT_2 1.41421356237\n#define SQRT_3 1.73205080757\n#define SQRT_5 2.2360679775\n#define SQRT_6 2.44949\n#define SQRT_7 2.64575\n#define SQRT_10 3.16228\n#define SQRT_14 3.74166\n#define SQRT_15 3.87298\n#define SQRT_35 5.91608\n\nfloat o_1_0_0_real(float Q, float x, float y, float z) {\n  float r = sqrt(x*x + y*y + z*z);\n  return pow(Q, 1.5) * exp(-Q * r) / SQRT_PI;\n}\n\n\nfloat o_2_0_0_real(float Q, float x, float y, float z) {\n  float r = sqrt(x*x + y*y + z*z);\n  return (1.0 / 8.0) * SQRT_2 * pow(Q, 1.5) *\n      (-Q * r + 2.0) * exp(-0.5 * Q * r) / SQRT_PI;\n}\n\nfloat o_2_1_neg_1_real(float Q, float phi, float x, float y, float z) {\n  float r = sqrt(x*x + y*y + z*z);\n  float rxy = sqrt(x*x + y*y);\n  return (1.0 / 8.0) * pow(Q, 2.5) * rxy *\n      exp(-0.5 * Q * r) * cos(phi) / SQRT_PI;\n}\n\nfloat o_2_1_neg_1_imag(float Q, float phi, float x, float y, float z) {\n  float r = sqrt(x*x + y*y + z*z);\n  float rxy = sqrt(x*x + y*y);\n  return -1.0 / 8.0 * pow(Q, 2.5) * rxy *\n      exp(-0.5 * Q * r) * sin(phi) / SQRT_PI;\n}\n\nfloat o_2_1_0_real(float Q, float x, float y, float z) {\n  float r = sqrt(x*x + y*y + z*z);\n  return (1.0 / 8.0) * SQRT_2 * pow(Q, 2.5) * z *\n      exp(-0.5 * Q * r) / SQRT_PI;\n}\n\nfloat o_2_1_1_real(float Q, float x, float y, float z) {\n  float r = sqrt(x*x + y*y + z*z);\n  return -1.0 / 8.0 * pow(Q, 2.5) * x *\n      exp(-0.5 * Q * r) / SQRT_PI;\n}\n\nfloat o_2_1_1_imag(float Q, float x, float y, float z) {\n  float r = sqrt(x*x + y*y + z*z);\n  return -1.0 / 8.0 * pow(Q, 2.5) * y *\n      exp(-0.5 * Q * r) / SQRT_PI;\n}\n\nfloat o_3_0_0_real(float Q, float x, float y, float z) {\n  float r = sqrt(x*x + y*y + z*z);\n  return (1.0 / 243.0) * SQRT_3 * pow(Q, 1.5) *\n      (2.0 * Q*Q * r*r - 18.0 * Q * r + 27.0) *\n      exp(-1.0 / 3.0 * Q * r) / SQRT_PI;\n}\n\nfloat o_3_1_neg_1_real(float Q, float phi, float x, float y, float z) {\n  float r = sqrt(x*x + y*y + z*z);\n  float rxy = sqrt(x*x + y*y);\n  return (1.0 / 81.0) * pow(Q, 2.5) * rxy *\n      (-Q * r + 6.0) * exp(-1.0 / 3.0 * Q * r) * cos(phi) / SQRT_PI;\n}\n\nfloat o_3_1_neg_1_imag(float Q, float phi, float x, float y, float z) {\n  float r = sqrt(x*x + y*y + z*z);\n  float rxy = sqrt(x*x + y*y);\n  return -1.0 / 81.0 * pow(Q, 2.5) * rxy *\n      (-Q * r + 6.0) * exp(-1.0 / 3.0 * Q * r) * sin(phi) / SQRT_PI;\n}\n\nfloat o_3_1_0_real(float Q, float x, float y, float z) {\n  float r = sqrt(x*x + y*y + z*z);\n  return (1.0 / 81.0) * SQRT_2 * pow(Q, 2.5) * z *\n      (-Q * r + 6.0) * exp(-1.0 / 3.0 * Q * r) / SQRT_PI;\n}\n\nfloat o_3_1_1_real(float Q, float x, float y, float z) {\n  float r = sqrt(x*x + y*y + z*z);\n  return (1.0 / 81.0) * pow(Q, 2.5) * x *\n      (Q * r - 6.0) * exp(-1.0 / 3.0 * Q * r) / SQRT_PI;\n}\n\nfloat o_3_1_1_imag(float Q, float x, float y, float z) {\n  float r = sqrt(x*x + y*y + z*z);\n  return (1.0 / 81.0) * pow(Q, 2.5) * y *\n      (Q * r - 6.0) * exp(-1.0 / 3.0 * Q * r) / SQRT_PI;\n}\n\nfloat o_3_2_neg_2_real(float Q, float phi, float x, float y, float z) {\n  float r = sqrt(x*x + y*y + z*z);\n  float rxy_sq = x*x + y*y;\n  return (1.0 / 162.0) * pow(Q, 3.5) * rxy_sq *\n      exp(-1.0 / 3.0 * Q * r) * cos(2.0 * phi) / SQRT_PI;\n}\n\nfloat o_3_2_neg_2_imag(float Q, float phi, float x, float y, float z) {\n  float r = sqrt(x*x + y*y + z*z);\n  float rxy_sq = x*x + y*y;\n  return -1.0 / 162.0 * pow(Q, 3.5) * rxy_sq *\n      exp(-1.0 / 3.0 * Q * r) * sin(2.0 * phi) / SQRT_PI;\n}\n\nfloat o_3_2_neg_1_real(float Q, float phi, float x, float y, float z) {\n  float r = sqrt(x*x + y*y + z*z);\n  float rxy = sqrt(x*x + y*y);\n  return (1.0 / 81.0) * pow(Q, 3.5) * z * rxy *\n      exp(-1.0 / 3.0 * Q * r) * cos(phi) / SQRT_PI;\n}\n\nfloat o_3_2_neg_1_imag(float Q, float phi, float x, float y, float z) {\n  float r = sqrt(x*x + y*y + z*z);\n  float rxy = sqrt(x*x + y*y);\n  return -1.0 / 81.0 * pow(Q, 3.5) * z * rxy *\n      exp(-1.0 / 3.0 * Q * r) * sin(phi) / SQRT_PI;\n}\n\nfloat o_3_2_0_real(float Q, float x, float y, float z) {\n  float r = sqrt(x*x + y*y + z*z);\n  return (1.0 / 486.0) * SQRT_6 * pow(Q, 3.5) *\n      (-x*x - y*y + 2.0 * z*z) * exp(-1.0 / 3.0 * Q * r) / SQRT_PI;\n}\n\nfloat o_3_2_1_real(float Q, float x, float y, float z) {\n  float r = sqrt(x*x + y*y + z*z);\n  return -1.0 / 81.0 * pow(Q, 3.5) * x * z *\n      exp(-1.0 / 3.0 * Q * r) / SQRT_PI;\n}\n\nfloat o_3_2_1_imag(float Q, float x, float y, float z) {\n  float r = sqrt(x*x + y*y + z*z);\n  return -1.0 / 81.0 * pow(Q, 3.5) * y * z *\n      exp(-1.0 / 3.0 * Q * r) / SQRT_PI;\n}\n\nfloat o_3_2_2_real(float Q, float phi, float x, float y, float z) {\n  float r = sqrt(x*x + y*y + z*z);\n  float rxy_sq = x*x + y*y;\n  return (1.0 / 162.0) * pow(Q, 3.5) * rxy_sq *\n      exp(-1.0 / 3.0 * Q * r) * cos(2.0 * phi) / SQRT_PI;\n}\n\nfloat o_3_2_2_imag(float Q, float phi, float x, float y, float z) {\n  float r = sqrt(x*x + y*y + z*z);\n  float rxy_sq = x*x + y*y;\n  return (1.0 / 162.0) * pow(Q, 3.5) * rxy_sq *\n      exp(-1.0 / 3.0 * Q * r) * sin(2.0 * phi) / SQRT_PI;\n}\n\nfloat o_4_0_0_real(float Q, float x, float y, float z) {\n  float r = sqrt(x*x + y*y + z*z);\n  return (1.0 / 1536.0) * pow(Q, 1.5) *\n      (-pow(Q, 3.0) * r*r*r + 24.0 * Q*Q * r*r - 144.0 * Q * r + 192.0) *\n      exp(-0.25 * Q * r) / SQRT_PI;\n}\n\nfloat o_4_1_neg_1_real(float Q, float phi, float x, float y, float z) {\n  float r = sqrt(x*x + y*y + z*z);\n  float rxy = sqrt(x*x + y*y);\n  return (1.0 / 5120.0) * SQRT_10 * pow(Q, 2.5) * rxy *\n      (Q*Q * r*r - 20.0 * Q * r + 80.0) *\n      exp(-0.25 * Q * r) * cos(phi) / SQRT_PI;\n}\n\nfloat o_4_1_neg_1_imag(float Q, float phi, float x, float y, float z) {\n  float r = sqrt(x*x + y*y + z*z);\n  float rxy = sqrt(x*x + y*y);\n  return -1.0 / 5120.0 * SQRT_10 * pow(Q, 2.5) * rxy *\n      (Q*Q * r*r - 20.0 * Q * r + 80.0) *\n      exp(-0.25 * Q * r) * sin(phi) / SQRT_PI;\n}\n\nfloat o_4_1_0_real(float Q, float x, float y, float z) {\n  float r = sqrt(x*x + y*y + z*z);\n  return (1.0 / 2560.0) * SQRT_5 * pow(Q, 2.5) * z *\n      (Q*Q * r*r - 20.0 * Q * r + 80.0) *\n      exp(-0.25 * Q * r) / SQRT_PI;\n}\n\nfloat o_4_1_1_real(float Q, float x, float y, float z) {\n  float r = sqrt(x*x + y*y + z*z);\n  return -1.0 / 5120.0 * SQRT_10 * pow(Q, 2.5) * x *\n      (Q*Q * r*r - 20.0 * Q * r + 80.0) *\n      exp(-0.25 * Q * r) / SQRT_PI;\n}\n\nfloat o_4_1_1_imag(float Q, float x, float y, float z) {\n  float r = sqrt(x*x + y*y + z*z);\n  return -1.0 / 5120.0 * SQRT_10 * pow(Q, 2.5) * y *\n      (Q*Q * r*r - 20.0 * Q * r + 80.0) *\n      exp(-0.25 * Q * r) / SQRT_PI;\n}\n\nfloat o_4_2_neg_2_real(float Q, float phi, float x, float y, float z) {\n  float r = sqrt(x*x + y*y + z*z);\n  float rxy_sq = x*x + y*y;\n  return -1.0 / 6144.0 * SQRT_6 * pow(Q, 3.5) * rxy_sq *\n      (Q * r - 12.0) * exp(-0.25 * Q * r) *\n      cos(2.0 * phi) / SQRT_PI;\n}\n\nfloat o_4_2_neg_2_imag(float Q, float phi, float x, float y, float z) {\n  float r = sqrt(x*x + y*y + z*z);\n  float rxy_sq = x*x + y*y;\n  return (1.0 / 6144.0) * SQRT_6 * pow(Q, 3.5) * rxy_sq *\n      (Q * r - 12.0) * exp(-0.25 * Q * r) *\n      sin(2.0 * phi) / SQRT_PI;\n}\n\nfloat o_4_2_neg_1_real(float Q, float phi, float x, float y, float z) {\n  float r = sqrt(x*x + y*y + z*z);\n  float rxy = sqrt(x*x + y*y);\n  return (1.0 / 3072.0) * pow(Q, 3.5) * z * SQRT_6 * rxy *\n      (-Q * r + 12.0) * exp(-0.25 * Q * r) * cos(phi) / SQRT_PI;\n}\n\nfloat o_4_2_neg_1_imag(float Q, float phi, float x, float y, float z) {\n  float r = sqrt(x*x + y*y + z*z);\n  float rxy = sqrt(x*x + y*y);\n  return -1.0 / 3072.0 * pow(Q, 3.5) * z * SQRT_6 * rxy *\n      (-Q * r + 12.0) * exp(-0.25 * Q * r) * sin(phi) / SQRT_PI;\n}\n\nfloat o_4_2_0_real(float Q, float x, float y, float z) {\n  float r = sqrt(x*x + y*y + z*z);\n  return (1.0 / 3072.0) * pow(Q, 3.5) *\n      (Q * r - 12.0) * (x*x + y*y - 2.0 * z*z) *\n      exp(-0.25 * Q * r) / SQRT_PI;\n}\n\nfloat o_4_2_1_real(float Q, float x, float y, float z) {\n  float r = sqrt(x*x + y*y + z*z);\n  return (1.0 / 3072.0) * SQRT_6 * pow(Q, 3.5) * x * z *\n      (Q * r - 12.0) * exp(-0.25 * Q * r) / SQRT_PI;\n}\n\nfloat o_4_2_1_imag(float Q, float x, float y, float z) {\n  float r = sqrt(x*x + y*y + z*z);\n  return (1.0 / 3072.0) * SQRT_6 * pow(Q, 3.5) * y * z *\n      (Q * r - 12.0) * exp(-0.25 * Q * r) / SQRT_PI;\n}\n\nfloat o_4_2_2_real(float Q, float phi, float x, float y, float z) {\n  float r = sqrt(x*x + y*y + z*z);\n  float rxy_sq = x*x + y*y;\n  return -1.0 / 6144.0 * SQRT_6 * pow(Q, 3.5) * rxy_sq *\n      (Q * r - 12.0) * exp(-0.25 * Q * r) *\n      cos(2.0 * phi) / SQRT_PI;\n}\n\nfloat o_4_2_2_imag(float Q, float phi, float x, float y, float z) {\n  float r = sqrt(x*x + y*y + z*z);\n  float rxy_sq = x*x + y*y;\n  return -1.0 / 6144.0 * SQRT_6 * pow(Q, 3.5) * rxy_sq *\n      (Q * r - 12.0) * exp(-0.25 * Q * r) *\n      sin(2.0 * phi) / SQRT_PI;\n}\n\nfloat o_4_3_neg_3_real(float Q, float phi, float x, float y, float z) {\n  float r = sqrt(x*x + y*y + z*z);\n  float rxy = sqrt(x*x + y*y);\n  return (1.0 / 6144.0) * pow(Q, 4.5) * pow(rxy, 3.0) *\n      exp(-0.25 * Q * r) * cos(3.0 * phi) / SQRT_PI;\n}\n\nfloat o_4_3_neg_3_imag(float Q, float phi, float x, float y, float z) {\n  float r = sqrt(x*x + y*y + z*z);\n  float rxy = sqrt(x*x + y*y);\n  return (1.0 / 6144.0) * pow(Q, 4.5) * pow(rxy, 3.0) *\n      exp(-0.25 * Q * r) * sin(-3.0 * phi) / SQRT_PI;\n}\n\nfloat o_4_3_neg_2_real(float Q, float phi, float x, float y, float z) {\n  float r = sqrt(x*x + y*y + z*z);\n  float rxy_sq = x*x + y*y;\n  return (1.0 / 6144.0) * SQRT_6 * pow(Q, 4.5) * z * rxy_sq *\n      exp(-0.25 * Q * r) * cos(2.0 * phi) / SQRT_PI;\n}\n\nfloat o_4_3_neg_2_imag(float Q, float phi, float x, float y, float z) {\n  float r = sqrt(x*x + y*y + z*z);\n  float rxy_sq = x*x + y*y;\n  return -1.0 / 6144.0 * SQRT_6 * pow(Q, 4.5) * z * rxy_sq *\n      exp(-0.25 * Q * r) * sin(2.0 * phi) / SQRT_PI;\n}\n\nfloat o_4_3_neg_1_real(float Q, float phi, float x, float y, float z) {\n  float r = sqrt(x*x + y*y + z*z);\n  float rxy = sqrt(x*x + y*y);\n  return (1.0 / 30720.0) * SQRT_15 * pow(Q, 4.5) *\n      (5.0 * z*z * rxy - rxy * r*r) *\n      exp(-0.25 * Q * r) * cos(phi) / (r * SQRT_PI);\n}\n\nfloat o_4_3_neg_1_imag(float Q, float phi, float x, float y, float z) {\n  float r = sqrt(x*x + y*y + z*z);\n  float rxy = sqrt(x*x + y*y);\n  return (1.0 / 30720.0) * SQRT_15 * pow(Q, 4.5) *\n      (5.0 * z*z * rxy - rxy * r*r) *\n      exp(-0.25 * Q * r) * sin(-phi) / (r * SQRT_PI);\n}\n\nfloat o_4_3_0_real(float Q, float x, float y, float z) {\n  float r = sqrt(x*x + y*y + z*z);\n  return (1.0 / 15360.0) * SQRT_5 * pow(Q, 4.5) * z *\n      (-3.0 * x*x - 3.0 * y*y + 2.0 * z*z) *\n      exp(-0.25 * Q * r) / SQRT_PI;\n}\n\nfloat o_4_3_1_real(float Q, float x, float y, float z) {\n  float r = sqrt(x*x + y*y + z*z);\n  return (1.0 / 30720.0) * SQRT_15 * pow(Q, 4.5) * x *\n      (x*x + y*y - 4.0 * z*z) *\n      exp(-0.25 * Q * r) / SQRT_PI;\n}\n\nfloat o_4_3_1_imag(float Q, float x, float y, float z) {\n  float r = sqrt(x*x + y*y + z*z);\n  return (1.0 / 30720.0) * SQRT_15 * pow(Q, 4.5) * y *\n      (x*x + y*y - 4.0 * z*z) *\n      exp(-0.25 * Q * r) / SQRT_PI;\n}\n\nfloat o_4_3_2_real(float Q, float phi, float x, float y, float z) {\n  float r = sqrt(x*x + y*y + z*z);\n  float rxy_sq = x*x + y*y;\n  return (1.0 / 6144.0) * SQRT_6 * pow(Q, 4.5) * z * rxy_sq *\n      exp(-0.25 * Q * r) * cos(2.0 * phi) / SQRT_PI;\n}\n\nfloat o_4_3_2_imag(float Q, float phi, float x, float y, float z) {\n  float r = sqrt(x*x + y*y + z*z);\n  float rxy_sq = x*x + y*y;\n  return (1.0 / 6144.0) * SQRT_6 * pow(Q, 4.5) * z * rxy_sq *\n      exp(-0.25 * Q * r) * sin(2.0 * phi) / SQRT_PI;\n}\n\nfloat o_4_3_3_real(float Q, float phi, float x, float y, float z) {\n  float r = sqrt(x*x + y*y + z*z);\n  float rxy = sqrt(x*x + y*y);\n  return -1.0 / 6144.0 * pow(Q, 4.5) * pow(rxy, 3.0) *\n      exp(-0.25 * Q * r) * cos(3.0 * phi) / SQRT_PI;\n}\n\nfloat o_4_3_3_imag(float Q, float phi, float x, float y, float z) {\n  float r = sqrt(x*x + y*y + z*z);\n  float rxy = sqrt(x*x + y*y);\n  return -1.0 / 6144.0 * pow(Q, 4.5) * pow(rxy, 3.0) *\n      exp(-0.25 * Q * r) * sin(3.0 * phi) / SQRT_PI;\n}\n\nvec2 orbital(int n, int l, int m, float Q, float x, float y, float z, float phase) {\n    float phi = phase;\n    \n    // Dispatch to the correct orbital function\n    if (n == 1 && l == 0 && m == 0) {\n        return vec2(o_1_0_0_real(Q, x, y, z), 0.0);\n    }\n    else if (n == 2 && l == 0 && m == 0) {\n        return vec2(o_2_0_0_real(Q, x, y, z), 0.0);\n    }\n    else if (n == 2 && l == 1 && m == -1) {\n        return vec2(o_2_1_neg_1_real(Q, phi, x, y, z), o_2_1_neg_1_imag(Q, phi, x, y, z));\n    }\n    else if (n == 2 && l == 1 && m == 0) {\n        return vec2(o_2_1_0_real(Q, x, y, z), 0.0);\n    }\n    else if (n == 2 && l == 1 && m == 1) {\n        return vec2(o_2_1_1_real(Q, x, y, z), o_2_1_1_imag(Q, x, y, z));\n    }\n    else if (n == 3 && l == 0 && m == 0) {\n        return vec2(o_3_0_0_real(Q, x, y, z), 0.0);\n    }\n    else if (n == 3 && l == 1 && m == -1) {\n        return vec2(o_3_1_neg_1_real(Q, phi, x, y, z), o_3_1_neg_1_imag(Q, phi, x, y, z));\n    }\n    else if (n == 3 && l == 1 && m == 0) {\n        return vec2(o_3_1_0_real(Q, x, y, z), 0.0);\n    }\n    else if (n == 3 && l == 1 && m == 1) {\n        return vec2(o_3_1_1_real(Q, x, y, z), o_3_1_1_imag(Q, x, y, z));\n    }\n    else if (n == 3 && l == 2 && m == -2) {\n        return vec2(o_3_2_neg_2_real(Q, phi, x, y, z), o_3_2_neg_2_imag(Q, phi, x, y, z));\n    }\n    else if (n == 3 && l == 2 && m == -1) {\n        return vec2(o_3_2_neg_1_real(Q, phi, x, y, z), o_3_2_neg_1_imag(Q, phi, x, y, z));\n    }\n    else if (n == 3 && l == 2 && m == 0) {\n        return vec2(o_3_2_0_real(Q, x, y, z), 0.0);\n    }\n    else if (n == 3 && l == 2 && m == 1) {\n        return vec2(o_3_2_1_real(Q, x, y, z), o_3_2_1_imag(Q, x, y, z));\n    }\n    else if (n == 3 && l == 2 && m == 2) {\n        return vec2(o_3_2_2_real(Q, phi, x, y, z), o_3_2_2_imag(Q, phi, x, y, z));\n    }\n    else if (n == 4 && l == 0 && m == 0) {\n        return vec2(o_4_0_0_real(Q, x, y, z), 0.0);\n    }\n    else if (n == 4 && l == 1 && m == -1) {\n        return vec2(o_4_1_neg_1_real(Q, phi, x, y, z), o_4_1_neg_1_imag(Q, phi, x, y, z));\n    }\n    else if (n == 4 && l == 1 && m == 0) {\n        return vec2(o_4_1_0_real(Q, x, y, z), 0.0);\n    }\n    else if (n == 4 && l == 1 && m == 1) {\n        return vec2(o_4_1_1_real(Q, x, y, z), o_4_1_1_imag(Q, x, y, z));\n    }\n    else if (n == 4 && l == 2 && m == -2) {\n        return vec2(o_4_2_neg_2_real(Q, phi, x, y, z), o_4_2_neg_2_imag(Q, phi, x, y, z));\n    }\n    else if (n == 4 && l == 2 && m == -1) {\n        return vec2(o_4_2_neg_1_real(Q, phi, x, y, z), o_4_2_neg_1_imag(Q, phi, x, y, z));\n    }\n    else if (n == 4 && l == 2 && m == 0) {\n        return vec2(o_4_2_0_real(Q, x, y, z), 0.0);\n    }\n    else if (n == 4 && l == 2 && m == 1) {\n        return vec2(o_4_2_1_real(Q, x, y, z), o_4_2_1_imag(Q, x, y, z));\n    }\n    else if (n == 4 && l == 2 && m == 2) {\n        return vec2(o_4_2_2_real(Q, phi, x, y, z), o_4_2_2_imag(Q, phi, x, y, z));\n    }\n    else if (n == 4 && l == 3 && m == -3) {\n        return vec2(o_4_3_neg_3_real(Q, phi, x, y, z), o_4_3_neg_3_imag(Q, phi, x, y, z));\n    }\n    else if (n == 4 && l == 3 && m == -2) {\n        return vec2(o_4_3_neg_2_real(Q, phi, x, y, z), o_4_3_neg_2_imag(Q, phi, x, y, z));\n    }\n    else if (n == 4 && l == 3 && m == -1) {\n        return vec2(o_4_3_neg_1_real(Q, phi, x, y, z), o_4_3_neg_1_imag(Q, phi, x, y, z));\n    }\n    else if (n == 4 && l == 3 && m == 0) {\n        return vec2(o_4_3_0_real(Q, x, y, z), 0.0);\n    }\n    else if (n == 4 && l == 3 && m == 1) {\n        return vec2(o_4_3_1_real(Q, x, y, z), o_4_3_1_imag(Q, x, y, z));\n    }\n    else if (n == 4 && l == 3 && m == 2) {\n        return vec2(o_4_3_2_real(Q, phi, x, y, z), o_4_3_2_imag(Q, phi, x, y, z));\n    }\n    else if (n == 4 && l == 3 && m == 3) {\n        return vec2(o_4_3_3_real(Q, phi, x, y, z), o_4_3_3_imag(Q, phi, x, y, z));\n    }\n    // Default: return zeros if orbital not found\n    return vec2(0.0, 0.0);\n}\n\nvec2 hydrogenOrbitalOptimized(vec3 pos, int n, int l, int m, float phase) {\n  return orbital(n, l, m, 1.0, pos.x, pos.y, pos.z, phase);\n}\n\n// Get combined wavefunction at a position (replacing the original function)\nvec2 getCombinedWavefunction(vec3 p) {\n    vec2 psi = vec2(0.0);\n    \n    // Compute the wavefunction for each orbital\n    for (int i = 0; i < 6; i++) { // Support for 6 orbitals\n        if (i >= orbital_count) break;\n        \n        float weight = orbital_weight[i];\n        if (weight > 0.001) {\n            vec2 orbitalPsi = hydrogenOrbitalOptimized(p, \n                                                      orbital_n[i], \n                                                      orbital_l[i], \n                                                      orbital_m[i], \n                                                      orbital_phase[i]);\n            psi += weight * orbitalPsi;\n        }\n    }\n    \n    return psi;\n}\n\n// Fast orbital color lookup\nvec3 getOrbitalColor(int l) {\n    // Colors for different angular momentum values\n    if (l == 0) return vec3(0.2, 0.5, 0.9);      // s: blue\n    if (l == 1) return vec3(1.0, 0.0, 0.0);      // p: red\n    if (l == 2) return vec3(0.0, 1.0, 0.0);      // d: green\n    if (l == 3) return vec3(1.0, 0.0, 1.0);      // f: purple\n    if (l == 4) return vec3(1.0, 1.0, 0.0);      // g: yellow\n    return vec3(0.5, 0.7, 0.7);                  // h+: teal\n}\n\n// Get mixed orbital color based on weights\nvec3 getMixedOrbitalColor() {\n    vec3 mixedColor = vec3(0.0);\n    float totalWeight = 0.0;\n    \n    // Sum all active orbital colors weighted by contribution\n    for (int i = 0; i < 6; i++) { // Support for 6 orbitals\n        if (i >= orbital_count) break;\n        \n        float weight = orbital_weight[i];\n        if (weight > 0.001) {\n            mixedColor += weight * getOrbitalColor(orbital_l[i]);\n            totalWeight += weight;\n        }\n    }\n    \n    return totalWeight > 0.0 ? mixedColor / totalWeight : vec3(0.5);\n}\n\n// Fast HSV to RGB conversion\nvec3 hsv2rgb(vec3 c) {\n    vec4 K = vec4(1.0, 2.0/3.0, 1.0/3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(vec3(1.0), clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nint getMaxN() {\n  int result = 0;\n  for(int i = 0; i < 6; i++) {\n    result = max(result, orbital_n[i]);\n  }\n  return result;\n}\n\n// Color palette function for visually appealing gradients\nvec3 orangeWhiteRed(float t) {\n    // Orange to white to red gradient\n    vec3 orange = vec3(1.0, 0.5, 0.0);\n    vec3 white = vec3(1.0, 1.0, 1.0);\n    vec3 red = vec3(0.9, 0.1, 0.1);\n    \n    if (t < 0.5) {\n        // Blend from orange to white\n        return mix(orange, white, t * 2.0);\n    } else {\n        // Blend from white to red\n        return mix(white, red, (t - 0.5) * 2.0);\n    }\n}\n\n// Updated raymarch function with better volume visualization\nvec4 raymarch(vec3 ro, vec3 rd) {\n    // Calculate orbital-specific maximum radius\n    float orbitalN = float(getMaxN());\n    float org = orbitalN == 1.0 ? 1.5 * orbitalN * orbitalN + 1.0 : 1.5 * orbitalN * orbitalN + 10.0;\n    float selectedQ = 1.0;\n    float maxDistance = min(MAX_DISTANCE, org / selectedQ);\n    \n    // Ray-box intersection test (adapted from volume shader)\n    vec3 box_min = vec3(-maxDistance);\n    vec3 box_max = vec3(maxDistance);\n    vec3 inv_dir = 1.0 / rd;\n    vec3 tmin_tmp = (box_min - ro) * inv_dir;\n    vec3 tmax_tmp = (box_max - ro) * inv_dir;\n    vec3 tmin = min(tmin_tmp, tmax_tmp);\n    vec3 tmax = max(tmin_tmp, tmax_tmp);\n    float t0 = max(tmin.x, max(tmin.y, tmin.z));\n    float t1 = min(tmax.x, min(tmax.y, tmax.z));\n    \n    // Check if ray misses the volume\n    if (t0 > t1) {\n        return vec4(0.0);\n    }\n    \n    // We don't want to sample points behind the eye\n    t0 = max(t0, 0.0);\n    \n    // Step size calculation (adaptive based on orbital size)\n    float dt = maxDistance * 2.0 / float(MAX_STEPS);\n    \n    // Add small offset to prevent artifacts\n    float offset = fract(sin(dot(vUv, vec2(12.9898, 78.233))) * 43758.5453);\n    \n    // Initialize accumulation color\n    vec4 color = vec4(0.0);\n    vec3 p = ro + t0 * rd + rd * dt * offset;\n    \n    // Adjustable parameters for volume rendering\n    float alphaScale = 5e-4; // Increased to show more volume\n    float volumeFactor = 1.5; // Boost volume visibility\n    \n    // Store isosurface position and value for later processing\n    vec3 isoPos = vec3(0.0);\n    float isoVal = 0.0;\n    bool foundIso = false;\n    \n    // Main ray marching loop\n    for (float t = t0; t < t1; t += dt) {\n        // Skip if we're outside the volume bounds\n        if (length(p) > maxDistance) {\n            p += rd * dt;\n            continue;\n        }\n        \n        // Calculate wavefunction and density\n        vec2 psi = getCombinedWavefunction(p);\n        float density = dot(psi, psi);\n        \n        if (density > DENSITY_THRESHOLD * 0.1) { // Lower threshold to capture more volume\n            // Determine color based on render mode\n            vec3 sampleColor;\n            float sampleAlpha;\n            float value = density;\n            \n            // Apply different visualization modes with improved coloring\n            if (renderMode == 0) {\n                // Probability density with orange-white-red color scheme\n                float normalizedDensity = smoothstep(DENSITY_THRESHOLD * 0.1, isovalue * 2.0, density);\n                sampleColor = orangeWhiteRed(normalizedDensity);\n                sampleAlpha = smoothstep(0.0, 0.25, density * alphaScale) * volumeFactor;\n            }\n            else if (renderMode == 1) {\n                // Real component \n                float realPart = psi.x;\n                float normalizedReal = (realPart + abs(realPart)) / (2.0 * max(abs(realPart), 1e-5));\n                sampleColor = orangeWhiteRed(normalizedReal);\n                sampleAlpha = smoothstep(0.0, 0.25, abs(realPart) * alphaScale * 1.5) * volumeFactor;\n                value = realPart;\n            }\n            else if (renderMode == 2) {\n                // Imaginary component\n                float imagPart = psi.y;\n                float normalizedImag = (imagPart + abs(imagPart)) / (2.0 * max(abs(imagPart), 1e-5));\n                sampleColor = orangeWhiteRed(normalizedImag);\n                sampleAlpha = smoothstep(0.0, 0.25, abs(imagPart) * alphaScale * 1.5) * volumeFactor;\n                value = imagPart;\n            }\n            else {\n                // Phase visualization with improved coloring\n                float phase = atan(psi.y, psi.x);\n                float hue = (phase + PI) / (2.0 * PI);\n                sampleColor = orangeWhiteRed(hue); // Using our color palette\n                sampleAlpha = smoothstep(0.0, 0.25, density * alphaScale) * volumeFactor;\n                value = sqrt(density);\n            }\n            \n            // Check for isosurface hit - store but don't break yet to continue capturing volume\n            if (!foundIso && density > isovalue) {\n                // Store isosurface position and value for later processing\n                isoPos = p;\n                isoVal = value;\n                foundIso = true;\n                \n                // Continue marching to collect volume information around isosurface\n                // (don't break immediately)\n            }\n            \n            // Front-to-back compositing for regular volume rendering\n            color.rgb += (1.0 - color.a) * sampleAlpha * sampleColor;\n            color.a += (1.0 - color.a) * sampleAlpha;\n            \n            // Early ray termination if fully opaque\n            if (color.a >= 0.98) break;\n        }\n        \n        // Move along the ray\n        p += rd * dt;\n    }\n    \n    // Process isosurface if found (after collecting volume information)\n    if (foundIso) {\n        // Calculate gradient for normal (central differences)\n        float step_size = dt * 0.5;\n        vec2 psi_x1 = getCombinedWavefunction(isoPos + vec3(step_size, 0.0, 0.0));\n        vec2 psi_x2 = getCombinedWavefunction(isoPos - vec3(step_size, 0.0, 0.0));\n        float grad_x = dot(psi_x1, psi_x1) - dot(psi_x2, psi_x2);\n        \n        vec2 psi_y1 = getCombinedWavefunction(isoPos + vec3(0.0, step_size, 0.0));\n        vec2 psi_y2 = getCombinedWavefunction(isoPos - vec3(0.0, step_size, 0.0));\n        float grad_y = dot(psi_y1, psi_y1) - dot(psi_y2, psi_y2);\n        \n        vec2 psi_z1 = getCombinedWavefunction(isoPos + vec3(0.0, 0.0, step_size));\n        vec2 psi_z2 = getCombinedWavefunction(isoPos - vec3(0.0, 0.0, step_size));\n        float grad_z = dot(psi_z1, psi_z1) - dot(psi_z2, psi_z2);\n        \n        vec3 normal = normalize(vec3(grad_x, grad_y, grad_z));\n        \n        // Enhanced lighting\n        vec3 lightPos1 = vec3(5.0, 5.0, 5.0);\n        vec3 lightPos2 = vec3(-5.0, 2.0, 3.0); // Second light for better shading\n        \n        vec3 lightDir1 = normalize(lightPos1 - isoPos);\n        vec3 lightDir2 = normalize(lightPos2 - isoPos);\n        \n        float diffuse1 = max(dot(normal, lightDir1), 0.0);\n        float diffuse2 = max(dot(normal, lightDir2), 0.0) * 0.5; // Second light is dimmer\n        \n        // Specular highlighting\n        vec3 viewDir = normalize(ro - isoPos);\n        vec3 reflectDir1 = reflect(-lightDir1, normal);\n        vec3 reflectDir2 = reflect(-lightDir2, normal);\n        \n        float specular1 = pow(max(dot(viewDir, reflectDir1), 0.0), 32.0);\n        float specular2 = pow(max(dot(viewDir, reflectDir2), 0.0), 32.0) * 0.3;\n        \n        // Generate color for isosurface based on value\n        float normalizedValue = (isoVal + abs(isoVal)) / (2.0 * max(abs(isoVal), 1e-5));\n        vec3 baseColor = orangeWhiteRed(normalizedValue);\n        \n        // Apply lighting to isosurface\n        vec3 litColor = baseColor * ((diffuse1 + diffuse2) * 0.7 + 0.3) + \n                        vec3(1.0) * (specular1 + specular2);\n        \n        // Blend isosurface with accumulated volume\n        float isoAlpha = 0.7; // Semi-transparent isosurface to show volume behind\n        vec4 isoColor = vec4(litColor, isoAlpha);\n        \n        // Blend isosurface with accumulated volume\n        color.rgb = mix(color.rgb, isoColor.rgb, isoAlpha * (1.0 - color.a));\n        color.a = color.a + isoAlpha * (1.0 - color.a);\n    }\n    \n    // Tone mapping (improved to preserve more color detail)\n    color.rgb = color.rgb / (1.0 + color.rgb);\n    \n    // Add subtle ambient occlusion effect\n    float ao = 1.0 - color.a * 0.2;\n    color.rgb *= ao;\n    \n    return color;\n}\n\nvoid main() {\n    // Generate ray\n    vec2 uv = vUv * 2.0 - 1.0;\n    uv.x *= aspectRatio;\n    \n    vec3 rayDirection = normalize(cameraDirection + uv.x * cameraRight + uv.y * cameraUp);\n    \n    // Perform ray marching\n    vec4 result = raymarch(cameraPos, rayDirection);\n    \n    // Background blend\n    vec3 backgroundColor = vec3(1.0);\n    vec3 finalColor = mix(backgroundColor, result.rgb, result.a);\n    \n    // Output\n    gl_FragColor = vec4(finalColor, 1.0);\n}",side:i.DoubleSide})}),[i,s,p,_]),c=()=>{if(!x.uniforms)return;x.uniforms.aspectRatio.value=t.width/t.height,x.uniforms.cameraPos.value.copy(n.position);const e=new i.Vector3(0,0,-1);e.applyQuaternion(n.quaternion),x.uniforms.cameraDirection.value.copy(e);const o=new i.Vector3(0,1,0);o.applyQuaternion(n.quaternion),x.uniforms.cameraUp.value.copy(o);const a=new i.Vector3(1,0,0);a.applyQuaternion(n.quaternion),x.uniforms.cameraRight.value.copy(a)};return(0,a.useEffect)((()=>{if(!x.uniforms)return;const n=_.map((n=>({n:n.n,l:n.l,m:n.m,weight:n.enabled?n.weight:0,phase:n.phase})));x.uniforms.orbital_n.value=n.map((n=>n.n)),x.uniforms.orbital_l.value=n.map((n=>n.l)),x.uniforms.orbital_m.value=n.map((n=>n.m)),x.uniforms.orbital_weight.value=n.map((n=>n.weight)),x.uniforms.orbital_phase.value=n.map((n=>n.phase)),x.uniforms.orbital_count.value=_.length,x.uniforms.renderMode.value=s,c()}),[x,_,s]),(0,r.C)(((n,e)=>{f.current&&(x.uniforms.time.value+=e,c())})),(0,l.jsxs)("mesh",{ref:f,frustumCulled:!1,children:[(0,l.jsx)("planeGeometry",{args:[2,2]})," ",(0,l.jsx)("primitive",{object:x,attach:"material"})]})};return(0,l.jsxs)("div",{style:{position:"relative",height:"500px"},children:[(0,l.jsxs)("div",{style:{position:"absolute",zIndex:10,padding:"10px",background:"rgba(0,0,0,0.7)",color:"white",borderRadius:"5px",maxHeight:"500px",overflowY:"auto",width:"300px"},children:[(0,l.jsxs)("div",{style:{marginBottom:"15px"},children:[(0,l.jsx)("h3",{style:{margin:"0 0 10px 0"},children:"Orbital Mixing"}),(0,l.jsxs)("div",{children:[(0,l.jsx)("button",{onClick:()=>{if(_.length<m){const n={n:1,l:0,m:0,weight:1,phase:0,enabled:!0};x([..._,n]),u(_.length)}},disabled:_.length>=m,style:{background:"#4CAF50",color:"white",border:"none",padding:"5px 10px",marginRight:"10px",borderRadius:"3px",cursor:_.length>=m?"not-allowed":"pointer",opacity:_.length>=m?.5:1},children:"Add Orbital"}),(0,l.jsx)("button",{onClick:()=>{const n=_.filter((n=>n.enabled));if(0===n.length)return;const e=n.reduce(((n,e)=>n+e.weight),0);if(e>0){const n=[..._];for(let o=0;o<n.length;o++)n[o].enabled&&(n[o].weight=n[o].weight/e);x(n)}},style:{background:"#2196F3",color:"white",border:"none",padding:"5px 10px",borderRadius:"3px",cursor:"pointer"},children:"Normalize Weights"})]})]}),_.map(((n,e)=>{return(0,l.jsxs)("div",{style:{marginBottom:"15px",padding:"10px",background:e===y?"rgba(255,255,255,0.1)":"transparent",borderRadius:"5px",border:"1px solid rgba(255,255,255,0.2)"},children:[(0,l.jsxs)("div",{style:{display:"flex",justifyContent:"space-between",alignItems:"center",marginBottom:"5px"},children:[(0,l.jsx)("strong",{style:{fontSize:"16px"},children:(o=n.n,t=n.l,a=n.m,`${o}${["s","p","d","f","g","h"][t]}${0!==a?` (m=${a})`:""}`)}),(0,l.jsxs)("div",{children:[(0,l.jsx)("button",{onClick:()=>u(e),style:{background:"transparent",color:"white",border:"1px solid white",padding:"2px 5px",marginRight:"5px",borderRadius:"3px",cursor:"pointer"},children:"Edit"}),(0,l.jsx)("button",{onClick:()=>(n=>{const e=[..._];e[n].enabled=!e[n].enabled,x(e)})(e),style:{background:n.enabled?"#4CAF50":"#f44336",color:"white",border:"none",padding:"2px 5px",marginRight:"5px",borderRadius:"3px",cursor:"pointer"},children:n.enabled?"On":"Off"}),_.length>1&&(0,l.jsx)("button",{onClick:()=>(n=>{if(_.length>1){const e=_.filter(((e,o)=>o!==n));x(e),y>=e.length?u(e.length-1):y===n&&u(Math.max(0,n-1))}})(e),style:{background:"#f44336",color:"white",border:"none",padding:"2px 5px",borderRadius:"3px",cursor:"pointer"},children:"\xd7"})]})]}),e===y&&(0,l.jsxs)("div",{children:[(0,l.jsxs)("div",{children:[(0,l.jsx)("label",{children:"n: "}),(0,l.jsx)("input",{type:"range",min:"1",max:"5",value:n.n,onChange:n=>h(e,"n",n.target.value)}),(0,l.jsx)("span",{children:n.n})]}),(0,l.jsxs)("div",{children:[(0,l.jsx)("label",{children:"l: "}),(0,l.jsx)("input",{type:"range",min:"0",max:n.n-1,value:n.l,onChange:n=>h(e,"l",n.target.value)}),(0,l.jsx)("span",{children:n.l})]}),(0,l.jsxs)("div",{children:[(0,l.jsx)("label",{children:"m: "}),(0,l.jsx)("input",{type:"range",min:-n.l,max:n.l,value:n.m,onChange:n=>h(e,"m",n.target.value)}),(0,l.jsx)("span",{children:n.m})]}),(0,l.jsxs)("div",{children:[(0,l.jsx)("label",{children:"Phase: "}),(0,l.jsx)("input",{type:"range",min:"0",max:"6.28",step:"0.01",value:n.phase,onChange:n=>h(e,"phase",n.target.value)}),(0,l.jsxs)("span",{children:[(n.phase/Math.PI).toFixed(2),"\u03c0"]})]})]}),(0,l.jsxs)("div",{children:[(0,l.jsx)("label",{children:"Weight: "}),(0,l.jsx)("input",{type:"range",min:"0.1",max:"10",step:"0.01",value:n.weight,disabled:!n.enabled,onChange:n=>h(e,"weight",n.target.value)}),(0,l.jsx)("span",{children:n.weight.toFixed(2)})]})]},e);var o,t,a})),(0,l.jsxs)("div",{style:{marginTop:"20px"},children:[(0,l.jsx)("label",{children:"Visualization: "}),(0,l.jsxs)("select",{value:s,onChange:n=>f(parseInt(n.target.value)),style:{background:"rgba(0,0,0,0.5)",color:"white",border:"1px solid #555",width:"100%",padding:"5px"},children:[(0,l.jsx)("option",{value:"0",children:"Probability Density"}),(0,l.jsx)("option",{value:"1",children:"Real Component"}),(0,l.jsx)("option",{value:"2",children:"Imaginary Component"}),(0,l.jsx)("option",{value:"3",children:"Phase"}),(0,l.jsx)("option",{value:"4",children:"Real/Imaginary Mix"})]}),(0,l.jsxs)("div",{children:[(0,l.jsx)("label",{children:"Isovalue: "}),(0,l.jsx)("input",{type:"range",min:"0.1",max:"100",step:"0.1",value:(p/1e-6).toFixed(0),onChange:n=>c(1e-6*parseFloat(n.target.value))}),(0,l.jsxs)("span",{children:[(p/1e-6).toFixed(2),"e-6"]})]})]})]}),(0,l.jsxs)(o,{camera:{position:[0,10,10],zoom:1.5,near:.1,far:1e3,orthographic:!0},style:{background:"#111",height:"500px"},children:[(0,l.jsx)("ambientLight",{intensity:.5}),(0,l.jsx)("pointLight",{position:[10,10,10]}),(0,l.jsx)(d,{}),(0,l.jsx)(t,{})]}),(0,l.jsxs)("div",{style:{position:"absolute",right:"10px",top:"10px",padding:"10px",background:"rgba(0,0,0,0.7)",color:"white",borderRadius:"5px",maxWidth:"250px",fontSize:"14px"},children:[(0,l.jsx)("h3",{style:{margin:"0 0 10px 0"},children:"Orbital Mixer"}),(0,l.jsx)("p",{children:"Mix up to 6 atomic orbitals to visualize quantum superpositions."}),(0,l.jsxs)("ul",{style:{paddingLeft:"20px",margin:"5px 0"},children:[(0,l.jsxs)("li",{children:["Use ",(0,l.jsx)("strong",{children:"Edit"})," to modify orbital parameters"]}),(0,l.jsxs)("li",{children:["Adjust ",(0,l.jsx)("strong",{children:"Weight"})," to control contribution"]}),(0,l.jsxs)("li",{children:["Toggle orbitals ",(0,l.jsx)("strong",{children:"On/Off"})," with the button"]}),(0,l.jsxs)("li",{children:["Use ",(0,l.jsx)("strong",{children:"Phase"})," to control quantum phase"]}),(0,l.jsxs)("li",{children:["Click ",(0,l.jsx)("strong",{children:"Normalize"})," to balance weights"]})]}),(0,l.jsx)("p",{children:"Try mixing s and p orbitals to create hybrid orbitals, or explore complex superpositions!"})]})]})},s=()=>{const[n,e]=(0,a.useState)(!1),[t,r]=(0,a.useState)(null);return(0,a.useEffect)((()=>{(async()=>{try{const n=await Promise.resolve().then(o.bind(o,9437)),t=await o.e(2428).then(o.bind(o,2428)),a=await o.e(5276).then(o.bind(o,5276));r({Canvas:t.Canvas,OrbitControls:a.OrbitControls,THREE:n}),e(!0)}catch(n){console.error("Failed to load Three.js libraries:",n)}})()}),[]),n&&t?(0,l.jsx)(i,{Components:t}):(0,l.jsx)("div",{children:"Loading 3D visualization..."})};function f(){return(0,l.jsx)(t.A,{title:"Quantum Mechanics Visualizations",description:"Interactive visualizations of quantum mechanics concepts",children:(0,l.jsxs)("main",{children:[(0,l.jsx)("h2",{children:"Hydrogenic orbitals"}),(0,l.jsx)(s,{})]})})}}}]);
"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([[8130],{7735:e=>{e.exports=JSON.parse('{"archive":{"blogPosts":[{"id":"MO_rotation","metadata":{"permalink":"/blog/MO_rotation","source":"@site/blog/2022-01-25-sph-cart.md","title":"How to rotate MO coefficients","description":"If you\'re a masochist like me, and you\'re writing or have written a quantum chemistry","date":"2022-01-25T00:00:00.000Z","tags":[{"inline":true,"label":"qm","permalink":"/blog/tags/qm"},{"inline":true,"label":"molecular orbitals","permalink":"/blog/tags/molecular-orbitals"},{"inline":true,"label":"linear algebra","permalink":"/blog/tags/linear-algebra"}],"readingTime":7.555,"hasTruncateMarker":false,"authors":[{"name":"Peter R. Spackman","title":"Research Fellow @ Curtin University","url":"https://github.com/peterspackman","imageURL":"https://github.com/peterspackman.png","key":"prs","page":null}],"frontMatter":{"slug":"MO_rotation","title":"How to rotate MO coefficients","authors":["prs"],"tags":["qm","molecular orbitals","linear algebra"]},"unlisted":false,"nextItem":{"title":"Wordle","permalink":"/blog/wordle"}},"content":"If you\'re a masochist like me, and you\'re writing or have written a quantum chemistry\\nprogram, you\'ll want to rotate molecular orbital (MO) coefficients\\nto save yourself recalculating wavefunctions at different positions/orientations.\\nNow that I\'ve sufficiently reduced the interested audience for this to the point we\\ncould fit in the seats of a social-distanced sedan, let me take you on a painful \\nbut *hopefully* helpful journey.\\n\\nThroughout this I\'m going to assume that all rotations are about some common origin, $\\\\mathbf{O}$,\\nbut of course you\'re welcome to double the pain and mix in rotations about arbitrary points in space if you wish to be more general. I\'m also going to put aside the various different\\nordering conventions, which will probably make you pull your hair out if you try to\\ninteroperate between many different programs.\\n\\nBut first we need a quick refresher on the difference between Cartesian and spherical/pure \\nGaussian basis sets like those used in quantum chemistry.\\nNote that throughout this I\'m going to ignore elaboration of the different normalizations\\nwithin contracted Gaussians, because frankly that just makes the equations more verbose...\\n\\n## Contracted Gaussian basis sets\\nContracted Gaussian functions are of the form\\n\\n$$\\n\\\\chi(\\\\mathbf{r}, \\\\mathbf{r_k}) = \\\\sum_k^K c_k N f(\\\\mathbf{r} - \\\\mathbf{r_k}) e^{-\\\\alpha_k |\\\\mathbf{r} - \\\\mathbf{r_k}|^2}\\n$$\\n\\nwhere $K$ is the degree of contraction (i.e. number of primitive Gaussian functions),\\n$N$ is the normalization constant we\'re going to ignore for now, $\\\\alpha_k$ is the\\nexponent for each primitive basis function and $c_k$ the contraction coefficient.\\n\\nTypically these sorts of basis sets will be in some library read in by the QM program of choice,\\ne.g. this is an excerpt from the STO-3G basis set in `.gbs` format, with the left column being\\nthe $\\\\alpha_k$, and the right column being $c_k$\\n\\n```\\nH     0 \\nS   3   1.00\\n      3.42525091             0.15432897       \\n      0.62391373             0.53532814       \\n      0.16885540             0.44463454   \\n```\\n\\nWith the exception of the $f(\\\\mathbf{r} - \\\\mathbf{r_k})$ term, $\\\\chi$ is purely radial.\\nHowever, there are two common choices of $f$: Cartesian and spherical.\\n\\n## Cartesian polynomials\\n\\nIn a Cartesian Gaussian basis set, $f$ takes the following form based on angular momentum $l$:\\n\\n$$\\n\\\\mathbf{r} - \\\\mathbf{r_k} = \\\\{x,y,z\\\\}\\\\\\\\\\nf(x,y,z) = x^i y^j z^k\\n$$\\n\\nwhere $i + j + k = l$ and all of $i,j,k$ are whole numbers.\\n\\nBecause multiplication is commutative i.e. $x^2 y = y x^2$, for each angular momenta, $l$, there are a number of \'unique\' \\nfunctions e.g.\\n\\n\\n| Label   | Angular momentum  | #  | Components           |\\n| ------- | ----------------- | -- | --------          |\\n| $p$     | $l = 1$           | **3**  | $x$, $y$. $z$           |\\n| $d$     | $l = 2$           | **6**  | $xx$, $xy$, $xz$, $yz$, $zz$  |\\n| $f$     | $l = 3$           | **10** | $xxx$, $xxy$, $xxz$, $xyy$, $xyz$, $xzz$, $yyy$, $yyz$, $yzz$, $zzz$ |\\n\\nand so on...\\n\\n\\n## Spherical/Pure polynomials\\n\\nIn a pure (or spherical) Gaussian basis set, $f$ usually corresponds to the *real* regular\\nsolid harmonics, which are directly related to the usual spherical harmonics $Y_l^m$\\nThese are a bit more of a rabbit hole..\\n\\n**Spherical harmonics ($Y_l^m$)**\\n\\nA much better overview of the spherical harmonics and their derivation can be found on\\n[wikipedia](https://en.wikipedia.org/wiki/Spherical_harmonics) or in any number of other\\nplaces.\\n\\nNevertheless, they take the form:\\n\\n$$\\nY_l^m(\\\\theta,\\\\phi) = N e^{im\\\\phi} P_l^m \\\\cos \\\\theta\\n$$\\n\\nwhere $N$ is yet another different normalization factor, $\\\\theta$ and $\\\\phi$ are the polar \\nangle/colatitude $[0, \\\\pi]$ and the azimuthal angle/longitude $[0, 2 \\\\pi]$ respectively, \\nand $P_l^m$ is an  [associated Legendre Polynomial](https://en.wikipedia.org/wiki/Associated_Legendre_polynomials)\\n\\n\\n**Regular solid harmonics ($R_l^m$)**\\n\\nGiven the previous definition of the spherical harmonics, the regular solid harmonics\\ntake the form:\\n\\n$$\\nR_l^m(r, \\\\theta, \\\\phi) = \\\\sqrt{\\\\frac{4 \\\\pi}{2 l + 1}} r^l Y_l^m(\\\\theta, \\\\phi)\\n$$\\n\\nor, simplified:\\n$$\\nR_l^m(r, \\\\theta, \\\\phi) = \\\\sqrt{\\\\frac{(l - m)!}{(l + m)!}} P_l^m(\\\\cos \\\\theta) e^{im\\\\phi}\\n$$\\n\\n***Real* regular solid harmonics ($R_{l,m}$)**\\n\\nFinally, the functions $f$ that are actually used are of the form:\\n\\n$$\\nf(r, \\\\theta, \\\\phi) = C_{l,m}(r, \\\\theta, \\\\phi)\\\\ \\\\mathrm{or}\\\\ S_{l,m}(r,\\\\theta,\\\\phi)\\n$$\\n\\nwhere\\n\\n$$\\nR_{l,0} = C_{l,0} = R_l^0\\\\\\\\\\nR_{l,m} = C_{l,m} = \\\\frac{1}{\\\\sqrt{2}}((-1)^m R_l^m + R_l^{-m})\\\\ \\\\mathrm{where}\\\\ m = 1 \\\\ldots l \\\\\\\\\\nR_{l,m} = S_{l,m} = \\\\frac{1}{i \\\\sqrt{2}}((-1)^m R_l^m + R_l^{-m})\\\\ \\\\mathrm{where}\\\\ m = -1 \\\\ldots -l \\\\\\\\\\n$$\\n\\nThis means that there are $2 l + 1$ components for a pure Gaussian basis with angular \\nmomentum $l$  e.g.: \\n\\n| Label   | Angular momentum  | #  | Components           |\\n| ------- | ----------------- | -- |---------          |\\n| $p$     | $l = 1$           | **3**  | $C_{10} = z$, $C_{11} = x$, $S_{11} = y$           |\\n| $d$     | $l = 2$           | **5**  | $C_{20}$, $C_{21}$, $S_{21}$, $C_{22}$, $S_{22}$  |\\n| $f$     | $l = 3$           | **7** | $C_{30}$, $C_{31}$, $S_{31}$, $C_{32}$, $S_{32}$, $C_{33}$, $S_{33}$ |\\n\\nThis should give a good idea why they find use in QM programs (fewer basis functions = fewer integrals to compute).\\n\\n\\n## Rotating Cartesian Gaussians\\n\\nOne way to imagine the molecular orbital coefficients associated\\nwith a Cartesian Gaussian is as an $l$ rank tensor e.g. a $3 \\\\times 3$\\nmatrix for a $d$ function, a $3 \\\\times 3 \\\\times 3$ cube for an $f$ etc.\\n\\nThis obviously is very wasteful, as only the upper triangle (or pyramid)\\nis permutationally unique. As such, they\'re typically stored as vectors\\n(or columns of a matrix) of length \\n\\n$$\\n\\\\frac{(l + 1)(l + 2)}{2}\\n$$\\n\\nThis usually renders rotation of these coefficients in real space to be\\ndone by hand coded routines rather than a simple matrix multiply.\\n\\nHowever, we can convert the rotation matrix into an appropriate matrix\\nto perform the conversion via the following algorithm implemented in C++:\\n\\n```cpp title=\\"cg_rotation_matrix.cpp\\"\\n/*\\n * Result should be R: an MxM rotation matrix for \\n * P: a MxN set of coordinates\\n * giving results P\' = R P\\n *\\n * Assume that the poorly named power_index_arrays gives\\n * arrays of length l that look like the following:\\n * xy = {0, 1}\\n * xyz = {0, 1, 2}\\n * xxy = {0, 0, 1}\\n * xyx = {0, 1, 0}\\n */\\ntemplate <int l>\\nMat cartesian_gaussian_rotation_matrix(const Mat3x3 rotation) {\\n    constexpr int num_moments = (l + 1) * (l + 2) / 2;\\n    Mat result = Mat::Zero(num_moments, num_moments);\\n    auto cg_powers = power_index_arrays<l>();\\n    int p1_idx = 0;\\n    for (const auto &p1: cg_powers) {\\n\\t    int p2_idx = 0;\\n\\t    // copy as we\'re permuting p2\\n        for (auto p2: cg_powers) {\\n            do {\\n                double tmp{1.0};\\n                for (int k = 0; k < l; k++) {\\n                    tmp *= rotation(p2[k], p1[k]);\\n                }\\n                result(p2_idx, p1_idx) += tmp;\\n            } while (std::next_permutation(p2.begin(), p2.end()));\\n\\t        p2_idx++;\\n        }\\n\\t    p1_idx++;\\n    }\\n    return result;\\n}\\n```\\n\\nIn essence this is just accounting for all the redundant terms we\'d\\nget that arise from the permutations of tensor indices. Going through\\nthe code line-by-line\\n\\n\\nSo our rotated column vector (or block of a matrix) of molecular orbital\\ncoefficients will simply be\\n\\n$$\\n\\\\mathbf{P}\' = \\\\mathbf{R} \\\\mathbf{P} \\n$$\\n\\n## Rotating pure Gaussians\\n\\nIf you\'ve made it this far, well now we\'re in for the more painful bit.\\n\\nObviously we can\'t directly use the above rotation matrix for a set of\\npure Gaussian molecular orbital coefficients, but we can convert the\\ncoefficients to their equivalent Cartesian representation, perform the\\nrotation, then convert back.\\n\\nFrankly, I find this alternative preferable to dealing with [Wigner D matrices](https://en.wikipedia.org/wiki/Wigner_D-matrix),\\n [Clebsch-Gordan coefficients](https://en.wikipedia.org/wiki/Clebsch%E2%80%93Gordan_coefficients) or any of the other painful aspects of\\nrotating spherical harmonics... \\n\\n\\n**Spherical to Cartesian transformations**\\n\\nThankfully, I\'m far from the first person to have wanted to perform this conversion,\\nso there are tabulated transforms (along with implementations to generate them) available\\ne.g., in [HORTON](https://theochem.github.io/horton/2.0.2/tech_ref_gaussian_basis.html#transformation-from-cartesian-to-pure-basis-functions). Much of this is based on\\nthe [Schlegel & Frisch paper](https://onlinelibrary.wiley.com/doi/10.1002/qua.560540202)\\nfrom the mid 90s.\\n\\nThis gives us $\\\\mathbf{c}$, a transformation matrix which will convert from Cartesian coefficients\\nto pure coefficients. But what of the inverse transform? $\\\\mathbf{c}$ is not an invertible matrix (obviously, as it\'s not square). Thankfully this is mentioned in the Schlegel & Frisch\\npaper, and we can find the inverse transformation via:\\n\\n$$\\n\\\\mathbf{c} \\\\mathbf{S} \\\\mathbf{c}^\\\\intercal = \\\\mathbf{I}\\n$$\\n\\n$$\\n\\\\mathbf{c}^{-1} = \\\\mathbf{S} \\\\mathbf{c}^\\\\intercal\\n$$\\n\\nHere $\\\\mathbf{S}$ is the matrix of overlap between normalized Cartesian gaussians\\nof the same total angular momentum, where (if $i,j,k$ are powers of $x,y,z$ respectively)\\n$\\\\mathbf{S}$ can be derived from the following horrible expression:\\n\\n$$\\nS(i_1, j_1, k_1, i_2, j_2, k_2) = \\\\frac{(i_1 + i_2)! (j_1 + j_2)! (k_1 + k_2)!}{((i_1 + i_2)/2)! ((j_1 + j_2)/2)! ((k_1 + k_2)/2)!}\\n \\\\times \\\\sqrt{\\\\frac{i_1 ! j_1 ! k_1 ! i_2 ! j_2 ! k_2 !}{(2 i_1)! (2 j_1)! (2 k_1)! (2 i_2)! (2 j_2)! (2 k_2)!}}\\n$$\\n\\nwhere all of $i_1 + i_2$, $j_1 + j_2$ and $k_1 + k_2$ are even, $0$ otherwise.\\n\\nThe neat part after all of this, is that we can simply transform $\\\\mathbf{R}$, the\\nCartesian Gaussian rotation matrix into $\\\\mathbf{R}\'$, the pure/spherical\\nGaussian rotation matrix as follows:\\n\\n$$\\n\\\\mathbf{R}\' = \\\\mathbf{c} \\\\mathbf{R} \\\\mathbf{c}^{-1}\\n$$\\n\\nand perform the rotation directly on the spherical molecular orbital coefficients:\\n\\n$$\\n\\\\mathbf{P}\' = \\\\mathbf{c} \\\\mathbf{R} \\\\mathbf{c}^{-1} \\\\mathbf{P}\\n$$\\n\\nWhew... Hopefully I don\'t have any errors in the equations, but if I do feel free\\nto name and shame me for being so sloppy."},{"id":"wordle","metadata":{"permalink":"/blog/wordle","source":"@site/blog/2022-01-19-wordle/index.mdx","title":"Wordle","description":"Wordle is a simple, elegant","date":"2022-01-19T00:00:00.000Z","tags":[{"inline":true,"label":"wordle","permalink":"/blog/tags/wordle"}],"readingTime":0.96,"hasTruncateMarker":false,"authors":[{"name":"Peter R. Spackman","title":"Research Fellow @ Curtin University","url":"https://github.com/peterspackman","imageURL":"https://github.com/peterspackman.png","key":"prs","page":null}],"frontMatter":{"slug":"wordle","title":"Wordle","authors":["prs"],"tags":["wordle"]},"unlisted":false,"prevItem":{"title":"How to rotate MO coefficients","permalink":"/blog/MO_rotation"},"nextItem":{"title":"Welcome","permalink":"/blog/welcome"}},"content":"import Spoiler from \'./wordleSolutions\'\\n\\n[Wordle](https://www.powerlanguage.co.uk/wordle/) is a simple, elegant\\nword game which has become massively popular, at least on twitter.\\n\\nSo far, the author hasn\'t commercialized it, and the social aspect\\nof comparing your performance for the same puzzle to others every day\\nclearly hits on something very appealing.\\n\\n\\nAs when any puzzle gets popular, there has been lots of discussion around\\nwordle solvers. You might think \\"Oh he\'s changed the date on his computer\\"\\nbut it\'s really nothing at all intelligent on my part.\\nSimply thanks to the hacker known as *View Page Source*, \\nI can reveal that it actually has a defined ordered list of words in plain text in\\nits source code.\\n\\nI searched for the word for today in the source and noticed that\\nthe previous words for the past few days were right there too, so\\nit was pretty clear that it indexing into this array of words based\\non date. While the code itself was minified, it was pretty straightforward\\nto look for uses of the array and deduce the method.\\n\\nSo without further ado, here\'s the ultimate strategy for completing wordle\\nevery day: **cheating**.\\n\\n<Spoiler></Spoiler>"},{"id":"welcome","metadata":{"permalink":"/blog/welcome","source":"@site/blog/2022-01-14-welcome/index.md","title":"Welcome","description":"Welcome to the blog section. Not much to see yet, but I plan on actually posting on here from time to time.","date":"2022-01-14T00:00:00.000Z","tags":[{"inline":true,"label":"hello","permalink":"/blog/tags/hello"},{"inline":true,"label":"blog","permalink":"/blog/tags/blog"}],"readingTime":0.345,"hasTruncateMarker":false,"authors":[{"name":"Peter R. Spackman","title":"Research Fellow @ Curtin University","url":"https://github.com/peterspackman","imageURL":"https://github.com/peterspackman.png","key":"prs","page":null}],"frontMatter":{"slug":"welcome","title":"Welcome","authors":["prs"],"tags":["hello","blog"]},"unlisted":false,"prevItem":{"title":"Wordle","permalink":"/blog/wordle"}},"content":"Welcome to the blog section. Not much to see yet, but I plan on actually posting on here from time to time.\\n\\nThis site is a mix of my personal site, and a wiki for me to write notes and equations related to my research\\nin a publicly accessible way.\\n\\nPartly so I have something to point people to for exposition, but mostly for my own reference and amusement."}]}}')}}]);
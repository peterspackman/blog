(()=>{var e,s,t,a,o,n,i={},r={};function l(e){var s=r[e];if(void 0!==s)return s.exports;var t=r[e]={exports:{}};return i[e](t,t.exports,l),t.exports}l.m=i,e="function"==typeof Symbol?Symbol("webpack queues"):"__webpack_queues__",s="function"==typeof Symbol?Symbol("webpack exports"):"__webpack_exports__",t="function"==typeof Symbol?Symbol("webpack error"):"__webpack_error__",a=e=>{e&&e.d<1&&(e.d=1,e.forEach((e=>e.r--)),e.forEach((e=>e.r--?e.r++:e())))},l.a=(o,n,i)=>{var r;i&&((r=[]).d=-1);var l,c,u,p=new Set,M=o.exports,g=new Promise(((e,s)=>{u=s,c=e}));g[s]=M,g[e]=e=>(r&&e(r),p.forEach(e),g.catch((e=>{}))),o.exports=g,n((o=>{var n;l=(o=>o.map((o=>{if(null!==o&&"object"==typeof o){if(o[e])return o;if(o.then){var n=[];n.d=0,o.then((e=>{i[s]=e,a(n)}),(e=>{i[t]=e,a(n)}));var i={};return i[e]=e=>e(n),i}}var r={};return r[e]=e=>{},r[s]=o,r})))(o);var i=()=>l.map((e=>{if(e[t])throw e[t];return e[s]})),c=new Promise((s=>{(n=()=>s(i)).r=0;var t=e=>e!==r&&!p.has(e)&&(p.add(e),e&&!e.d&&(n.r++,e.push(n)));l.map((s=>s[e](t)))}));return n.r?c:i()}),(e=>(e?u(g[t]=e):c(M),a(r)))),r&&r.d<0&&(r.d=0)},n=Object.getPrototypeOf?e=>Object.getPrototypeOf(e):e=>e.__proto__,l.t=function(e,s){if(1&s&&(e=this(e)),8&s)return e;if("object"==typeof e&&e){if(4&s&&e.__esModule)return e;if(16&s&&"function"==typeof e.then)return e}var t=Object.create(null);l.r(t);var a={};o=o||[null,n({}),n([]),n(n)];for(var i=2&s&&e;"object"==typeof i&&!~o.indexOf(i);i=n(i))Object.getOwnPropertyNames(i).forEach((s=>a[s]=()=>e[s]));return a.default=()=>e,l.d(t,a),t},l.d=(e,s)=>{for(var t in s)l.o(s,t)&&!l.o(e,t)&&Object.defineProperty(e,t,{enumerable:!0,get:s[t]})},l.f={},l.e=e=>Promise.all(Object.keys(l.f).reduce(((s,t)=>(l.f[t](e,s),s)),[])),l.u=e=>"assets/js/"+(4602===e?"em-pthread":e)+"."+{4602:"d4f855a1",7583:"50e6485b",8415:"d38f8669"}[e]+".js",l.miniCssF=e=>{},l.o=(e,s)=>Object.prototype.hasOwnProperty.call(e,s),l.r=e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},l.p="/",l.gca=function(e){return e={}[e]||e,l.p+l.u(e)},(()=>{l.b=self.location+"/../../../";var e={9761:1};l.f.i=(s,t)=>{e[s]||importScripts(l.p+l.u(s))};var s=self.webpackChunkblog=self.webpackChunkblog||[],t=s.push.bind(s);s.push=s=>{var a=s[0],o=s[1],n=s[2];for(var i in o)l.o(o,i)&&(l.m[i]=o[i]);for(n&&n(l);a.length;)e[a.pop()]=1;t(s)}})();let c=null,u=null;function p(e){const s=[];for(let o=0;o<50;o++)for(let e=0;e<50;e++){const t=o/50*Math.PI,a=e/50*2*Math.PI,n=Math.sin(t)*Math.cos(a),i=Math.sin(t)*Math.sin(a),r=Math.cos(t);if(Math.abs(n)>1e-10||Math.abs(i)>1e-10||Math.abs(r)>1e-10){const e=Math.sqrt(n*n+i*i+r*r);s.push(u.Vec3.create(n/e,i/e,r/e))}}const t={youngsModulus:{min:1/0,max:-1/0},linearCompressibility:{min:1/0,max:-1/0},shearModulus:{min:1/0,max:-1/0},poissonRatio:{min:1/0,max:-1/0}};for(const o of s)try{const s=e.youngsModulus(o);t.youngsModulus.min=Math.min(t.youngsModulus.min,s),t.youngsModulus.max=Math.max(t.youngsModulus.max,s);const a=e.linearCompressibility(o);t.linearCompressibility.min=Math.min(t.linearCompressibility.min,a),t.linearCompressibility.max=Math.max(t.linearCompressibility.max,a);const n=e.shearModulusMinMax(o);n&&(t.shearModulus.min=Math.min(t.shearModulus.min,n.min),t.shearModulus.max=Math.max(t.shearModulus.max,n.max));const i=e.poissonRatioMinMax(o);i&&(t.poissonRatio.min=Math.min(t.poissonRatio.min,i.min),t.poissonRatio.max=Math.max(t.poissonRatio.max,i.max))}catch(a){}return t.youngsModulus.anisotropy=t.youngsModulus.max/t.youngsModulus.min,t.linearCompressibility.anisotropy=t.linearCompressibility.max/t.linearCompressibility.min,t.shearModulus.anisotropy=t.shearModulus.max/t.shearModulus.min,t.poissonRatio.min>=0?t.poissonRatio.anisotropy=t.poissonRatio.max/t.poissonRatio.min:t.poissonRatio.max<=0?t.poissonRatio.anisotropy=t.poissonRatio.min/t.poissonRatio.max:t.poissonRatio.anisotropy=1/0,t}function M(e,s,t,a=180){const o=[];for(let i=0;i<=a;i++){const r=i/a*2*Math.PI;let l,c,p;"xy"===t?(l=Math.cos(r),c=Math.sin(r),p=0):"xz"===t?(l=Math.cos(r),c=0,p=Math.sin(r)):"yz"===t&&(l=0,c=Math.cos(r),p=Math.sin(r));const M=u.Vec3.create(l,c,p);let g=0,m=0,h=0;try{if("youngs"===s)g=e.youngsModulus(M),m=h=g;else if("linear_compressibility"===s)g=e.linearCompressibility(M),m=h=g;else if("shear"===s){const s=e.shearModulusMinMax(M);m=s.min,h=s.max,g=h}else if("poisson"===s){const s=e.poissonRatioMinMax(M);m=s.min,h=s.max,g=h}}catch(n){g=m=h=0}o.push({angle:180*r/Math.PI,angleRad:r,value:g,valueMin:m,valueMax:h})}return o}function g(e,s){const t=[];for(let n=0;n<=120;n++){const a=[];for(let t=0;t<=60;t++){const i=n/120*2*Math.PI,r=t/60*Math.PI,l=Math.sin(r)*Math.cos(i),c=Math.sin(r)*Math.sin(i),p=Math.cos(r),M=u.Vec3.create(l,c,p);let g=0;try{if("youngs"===s)g=e.youngsModulus(M);else if("linear_compressibility"===s)g=e.linearCompressibility(M);else if("shear"===s){const s=e.shearModulusMinMax(M);g=s?s.max:0}else if("poisson"===s){const s=e.poissonRatioMinMax(M);g=s?s.max:0}}catch(o){g=0}a.push(g)}t.push(a)}const a=t.flat();return{surfaceData:t,minValue:Math.min(...a),maxValue:Math.max(...a),property:s,numU:121,numV:61}}self.addEventListener("message",(async function(e){const{type:s,data:t}=e.data;try{switch(s){case"init":await async function(){try{postMessage({type:"log",level:2,message:"Initializing OCC in worker..."});try{c=await l.e(8415).then(l.bind(l,8415)),postMessage({type:"log",level:2,message:"Loaded OCC package"})}catch(e){return void postMessage({type:"initialized",success:!1,error:`OCC package import failed: ${e.message}. The WASM module contains Node.js-specific imports that don't work in browsers.`})}u=await c.loadOCC(),u.registerLogCallback&&u.registerLogCallback(((e,s)=>{postMessage({type:"log",level:e,message:s})})),postMessage({type:"initialized",success:!0})}catch(s){postMessage({type:"initialized",success:!1,error:s.message})}}();break;case"analyzeAll":await async function(e){try{const{tensors:t,properties:a=["youngs","linear_compressibility","shear","poisson"]}=e;postMessage({type:"log",level:2,message:`Starting comprehensive analysis for ${t.length} tensor(s)...`});const o=[];for(let e=0;e<t.length;e++){const n=t[e].data,i=t[e].id||e;let r;r=u.Mat6&&u.Mat6.create?u.Mat6.create(6,6):u.Mat.create(6,6);for(let e=0;e<6;e++)for(let s=0;s<6;s++)r.set(e,s,n[e][s]);const l=new u.ElasticTensor(r),c=[u.AveragingScheme.VOIGT,u.AveragingScheme.REUSS,u.AveragingScheme.HILL],m=["voigt","reuss","hill"],h={bulkModulus:{},shearModulus:{},youngsModulus:{},poissonRatio:{},linearCompressibility:{}};for(let e=0;e<c.length;e++){const s=c[e],t=m[e];h.bulkModulus[t]=l.averageBulkModulus(s),h.shearModulus[t]=l.averageShearModulus(s),h.youngsModulus[t]=l.averageYoungsModulus(s),h.poissonRatio[t]=l.averagePoissonRatio(s),h.linearCompressibility[t]=1e3/h.bulkModulus[t]}let y=null,f=!0,d=null;try{if(l.eigenvalues&&"function"==typeof l.eigenvalues){const e=l.eigenvalues();if(y=[],e&&e.size&&"function"==typeof e.size)for(let s=0;s<e.size();s++)y.push(e.get(s));else if(e&&void 0!==e.length)for(let s=0;s<e.length;s++)y.push(e[s]);else Array.isArray(e)&&(y=[...e]);y.sort(((e,s)=>e-s)),f=y.every((e=>e>0))}}catch(s){d=s.message,y=null}const v=p(l),x={},b=["xy","xz","yz"];for(const e of b){x[e]={};for(const s of a)x[e][s]=M(l,s,e,180)}const R={};for(const e of a)R[e]=g(l,e);const C=[],k=[],w=l.voigtC;for(let e=0;e<6;e++){const s=[];for(let t=0;t<6;t++)s.push(w.get(e,t));C.push(s)}const S=l.voigtS;for(let e=0;e<6;e++){const s=[];for(let t=0;t<6;t++)s.push(S.get(e,t));k.push(s)}o.push({id:i,properties:h,eigenvalues:y,eigenvalueError:d,isPositiveDefinite:f,extrema:v,directionalData:x,surfaceData:R,stiffnessMatrix:C,complianceMatrix:k})}postMessage({type:"analyzeAllResult",success:!0,data:o}),postMessage({type:"log",level:2,message:"Comprehensive analysis complete"})}catch(s){postMessage({type:"analyzeAllResult",success:!1,error:s.message})}}(t);break;case"analyzeTensor":await async function(s){try{postMessage({type:"log",level:2,message:"Starting elastic tensor analysis..."});const{tensorData:a}=s;let o;o=u.Mat6&&u.Mat6.create?u.Mat6.create(6,6):u.Mat.create(6,6);for(let e=0;e<6;e++)for(let s=0;s<6;s++)o.set(e,s,a[e][s]);const n=new u.ElasticTensor(o),i=[u.AveragingScheme.VOIGT,u.AveragingScheme.REUSS,u.AveragingScheme.HILL],r=["voigt","reuss","hill"],l={bulkModulus:{},shearModulus:{},youngsModulus:{},poissonRatio:{},linearCompressibility:{}};for(let e=0;e<i.length;e++){const s=i[e],t=r[e];l.bulkModulus[t]=n.averageBulkModulus(s),l.shearModulus[t]=n.averageShearModulus(s),l.youngsModulus[t]=n.averageYoungsModulus(s),l.poissonRatio[t]=n.averagePoissonRatio(s),l.linearCompressibility[t]=1e3/l.bulkModulus[t]}let c=null,p=!0,M=null;try{if(!n.eigenvalues||"function"!=typeof n.eigenvalues)throw new Error("eigenvalues() method not available in ElasticTensor");{const e=n.eigenvalues();if(c=[],e&&e.size&&"function"==typeof e.size)for(let s=0;s<e.size();s++)c.push(e.get(s));else if(e&&void 0!==e.length)for(let s=0;s<e.length;s++)c.push(e[s]);else{if(!Array.isArray(e))throw new Error("Unknown eigenvalue result format");c=[...e]}if(c.sort(((e,s)=>e-s)),p=c.every((e=>e>0)),postMessage({type:"log",level:2,message:`Retrieved ${c.length} eigenvalues: [${c.map((e=>e.toFixed(4))).join(", ")}]`}),!p){const e=c.filter((e=>e<=0)).length;postMessage({type:"log",level:1,message:`Warning: Tensor is not positive definite - ${e} eigenvalue(s) <= 0`})}}}catch(t){M=t.message,c=null,p=!0,postMessage({type:"log",level:1,message:`Could not calculate eigenvalues: ${t.message}`})}const g=50,m=[];for(let e=0;e<g;e++)for(let s=0;s<g;s++){const t=e/g*Math.PI,a=s/g*2*Math.PI,o=Math.sin(t)*Math.cos(a),n=Math.sin(t)*Math.sin(a),i=Math.cos(t);m.push(u.Vec3.create(o,n,i))}let h=1/0,y=-1/0,f=1/0,d=-1/0,v=1/0,x=-1/0,b=1/0,R=-1/0;m.forEach((s=>{try{const t=n.youngsModulus(s);h=Math.min(h,t),y=Math.max(y,t);const a=n.linearCompressibility(s);f=Math.min(f,a),d=Math.max(d,a);try{const e=n.shearModulusMinMax(s);e&&(v=Math.min(v,e.min),x=Math.max(x,e.max))}catch(e){const a=t/2.6;v=Math.min(v,a),x=Math.max(x,a)}try{const e=n.poissonRatioMinMax(s);e&&(b=Math.min(b,e.min),R=Math.max(R,e.max))}catch(e){const a=t/(t/3*2)-1;b=Math.min(b,Math.max(-1,a)),R=Math.max(R,Math.min(.5,a))}}catch(e){postMessage({type:"log",level:1,message:`Warning: Could not calculate property for direction: ${e.message}`})}}));const C={shearModulus:{min:v,max:x,anisotropy:x/v},youngsModulus:{min:h,max:y,anisotropy:y/h},poissonRatio:{min:b,max:R,anisotropy:Math.abs(R/b)},linearCompressibility:{min:f,max:d,anisotropy:d/f}},k=[],w=[],S=n.voigtC,P=n.voigtS;for(let e=0;e<6;e++){const s=[],t=[];for(let a=0;a<6;a++)s.push(S.get(e,a)),t.push(P.get(e,a));k.push(s),w.push(t)}postMessage({type:"analysisResult",success:!0,data:{properties:l,eigenvalues:c,eigenvalueError:M,isPositiveDefinite:p,extrema:C,stiffnessMatrix:k,complianceMatrix:w,elasticTensor:n}}),postMessage({type:"log",level:2,message:"Elastic tensor analysis complete"})}catch(t){postMessage({type:"analysisResult",success:!1,error:t.message})}}(t);break;case"generateDirectionalData":await async function(s){try{const{tensorData:t,property:a,plane:o,numPoints:n,isReference:i}=s;let r;postMessage({type:"log",level:2,message:`Generating directional data for ${a} ${o} (ref: ${i})...`}),r=u.Mat6&&u.Mat6.create?u.Mat6.create(6,6):u.Mat.create(6,6);for(let e=0;e<6;e++)for(let s=0;s<6;s++)r.set(e,s,t[e][s]);const l=new u.ElasticTensor(r);if(l.generateDirectionalData)try{const e=l.generateDirectionalData(a,n||180),s=[];for(let t=0;t<e.size();t++){const a=e.get(t);let n=a.x,i=a.y;if("xz"===o){const e=i;i=0,i=e}else if("yz"===o){const e=n;n=i,i=e}s.push({angle:180*a.angle/Math.PI,angleRad:a.angle,value:a.value,valueMin:a.value,valueMax:a.value,x:n,y:i})}return postMessage({type:"directionalDataResult",success:!0,data:s,plane:o,isReference:i||!1}),void postMessage({type:"log",level:2,message:"Directional data generation complete (WASM)"})}catch(e){postMessage({type:"log",level:1,message:`WASM method failed, using fallback: ${e.message}`})}const c=[];for(let s=0;s<=n;s++){const t=s/n*2*Math.PI;let i;i="xy"===o?u.Vec3.create(Math.cos(t),Math.sin(t),0):"xz"===o?u.Vec3.create(Math.cos(t),0,Math.sin(t)):u.Vec3.create(0,Math.cos(t),Math.sin(t));let r=0,p=0,M=0;try{if("youngs"===a)r=l.youngsModulus(i),p=M=r;else if("linear_compressibility"===a)r=l.linearCompressibility(i),p=M=r;else if("shear"===a){const e=l.shearModulusMinMax(i);p=e.min,M=e.max,r=M}else if("poisson"===a){const e=l.poissonRatioMinMax(i);p=e.min,M=e.max,r=M}}catch(e){r=p=M=0}c.push({angle:180*t/Math.PI,angleRad:t,value:r,valueMin:p,valueMax:M})}postMessage({type:"directionalDataResult",success:!0,data:c,plane:o,isReference:i||!1}),postMessage({type:"log",level:2,message:"Directional data generation complete"})}catch(t){postMessage({type:"directionalDataResult",success:!1,error:t.message})}}(t);break;case"generate3DSurfaceData":await async function(s){try{const{tensorData:t,property:a,isReference:o}=s;let n;postMessage({type:"log",level:2,message:`Generating 3D surface data for ${a}...`}),n=u.Mat6&&u.Mat6.create?u.Mat6.create(6,6):u.Mat.create(6,6);for(let e=0;e<6;e++)for(let s=0;s<6;s++)n.set(e,s,t[e][s]);const i=new u.ElasticTensor(n),r=120,l=60,c=[];for(let s=0;s<=r;s++){const t=[];for(let o=0;o<=l;o++){const n=s/r*2*Math.PI,c=o/l*Math.PI,p=Math.sin(c)*Math.cos(n),M=Math.sin(c)*Math.sin(n),g=Math.cos(c),m=u.Vec3.create(p,M,g);let h=0;try{if("youngs"===a)h=i.youngsModulus(m);else if("linear_compressibility"===a)h=i.linearCompressibility(m);else if("shear"===a){const e=i.shearModulusMinMax(m);h=e?e.max:0}else if("poisson"===a){const e=i.poissonRatioMinMax(m);h=e?e.max:0}}catch(e){h=0}t.push(h)}c.push(t)}const p=c.flat(),M=Math.min(...p),g=Math.max(...p);postMessage({type:"3DSurfaceResult",success:!0,data:{surfaceData:c,minValue:M,maxValue:g,property:a,numU:r+1,numV:l+1},isReference:o||!1}),postMessage({type:"log",level:2,message:"3D surface data generation complete"})}catch(t){postMessage({type:"3DSurfaceResult",success:!1,error:t.message})}}(t);break;default:postMessage({type:"error",error:`Unknown message type: ${s}`})}}catch(a){postMessage({type:"error",error:a.message||"Unknown error occurred",stack:a.stack})}}))})();
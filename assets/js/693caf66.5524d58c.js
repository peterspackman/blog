"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([[3611],{9082:(n,e,t)=>{t.r(e),t.d(e,{default:()=>c});var i=t(1410),a=t(6540),r=t(2111),o=t(4848);const l=n=>{let{Components:e}=n;const{Canvas:t,OrbitControls:i,THREE:l}=e,[s,c]=(0,a.useState)(0),[p,d]=(0,a.useState)([{n:2,l:1,m:0,weight:1,phase:0,enabled:!0}]),[u,m]=(0,a.useState)(0),[f]=(0,a.useState)(6),h=(n,e,t)=>{const i=[...p];if("n"===e){const e=parseInt(t);i[n].n=e,i[n].l>=e&&(i[n].l=e-1,Math.abs(i[n].m)>i[n].l&&(i[n].m=0))}else if("l"===e){const e=parseInt(t);i[n].l=e,Math.abs(i[n].m)>e&&(i[n].m=0)}else"m"===e?i[n].m=parseInt(t):"weight"===e?i[n].weight=parseFloat(t):"phase"===e?i[n].phase=parseFloat(t):"enabled"===e&&(i[n].enabled=t);d(i)},x=()=>{const{camera:n,gl:e,scene:t,size:i}=(0,r.A)(),c=(0,a.useRef)(),d=(0,a.useMemo)((()=>{const n=p.map((n=>({n:n.n,l:n.l,m:n.m,weight:n.enabled?n.weight:0,phase:n.phase})));return new l.ShaderMaterial({uniforms:{time:{value:0},renderMode:{value:s},aspectRatio:{value:1},edgeThreshold:{value:.01},edgeWidth:{value:1e-5},cameraPos:{value:new l.Vector3},cameraDirection:{value:new l.Vector3},cameraUp:{value:new l.Vector3},cameraRight:{value:new l.Vector3},orbital_n:{value:n.map((n=>n.n))},orbital_l:{value:n.map((n=>n.l))},orbital_m:{value:n.map((n=>n.m))},orbital_weight:{value:n.map((n=>n.weight))},orbital_phase:{value:n.map((n=>n.phase))},orbital_count:{value:p.length}},vertexShader:"\n          varying vec2 vUv;\n\n          void main() {\n            vUv = uv;\n            gl_Position = vec4(position, 1.0); // No projection needed for a screen-filling quad\n          }\n        ",fragmentShader:"\nprecision highp float;\n\nuniform float time;\nuniform float aspectRatio;\nuniform float edgeThreshold;\nuniform float edgeWidth;\nuniform int renderMode;\nuniform vec3 cameraPos;\nuniform vec3 cameraDirection;\nuniform vec3 cameraUp;\nuniform vec3 cameraRight;\n\n// Orbital data arrays - extended to 6 orbitals\nuniform int orbital_n[6];\nuniform int orbital_l[6];\nuniform int orbital_m[6];\nuniform float orbital_weight[6];\nuniform float orbital_phase[6];\nuniform int orbital_count;\n\nvarying vec2 vUv;\n\n#define PI 3.14159265359\n#define MAX_STEPS 100\n#define STEP_SIZE 0.5\n#define DENSITY_THRESHOLD 0.00002\n#define MAX_DISTANCE 100.0\n\n// Maximum L value we'll support\n#define MAX_L 4\n\n// Optimized cartesian calculation of spherical harmonics up to L=4\n// Replace the existing SH computation in your shader with this optimized version\n\n// Constants needed for normalization\n#define SQRT_PI 1.77245385091\n#define SQRT_2 1.41421356237\n#define SQRT_3 1.73205080757\n#define SQRT_5 2.2360679775\n#define SQRT_6 2.44949\n#define SQRT_7 2.64575\n#define SQRT_10 3.16228\n#define SQRT_14 3.74166\n#define SQRT_15 3.87298\n#define SQRT_35 5.91608\n\nfloat factorial(float n) {\n    // For L\u22644, the maximum factorial we need is 8! (for L=4, m=4)\n    if (n <= 0.0) return 1.0;\n    else if (n == 1.0) return 1.0;\n    else if (n == 2.0) return 2.0;\n    else if (n == 3.0) return 6.0;\n    else if (n == 4.0) return 24.0;\n    else if (n == 5.0) return 120.0;\n    else if (n == 6.0) return 720.0;\n    else if (n == 7.0) return 5040.0;\n    else if (n == 8.0) return 40320.0;\n    \n    // Fallback computation for larger values (should never be needed with MAX_L=4)\n    float o = 1.0;\n    for (float i = 1.0; i <= n; i++) \n        o *= i;\n    return o;\n}\n\n// Improved Laguerre function with fixed pointer issue\nfloat laguerre(float x, float k, float a) {\n    float L0 = 1.;\n    float L1 = 1.+a-x;\n    for (float i = 0.; i < k; i++) {\n        float t = ((2.*i+1.+a-x)*L1-(i+a)*L0)/(i+1.);\n        L0 = L1;\n        L1 = t;\n    }\n    return L1;\n}\n\n// Normalization function kept the same for compatibility\nfloat normalization(float n, float l) {\n    return sqrt(pow(2./n,3.)/(2.*n)*factorial(n-l-1.)/factorial(n+l));\n}\n\n// Computes spherical harmonic Y_l^m in Cartesian form\n// Input: normalized direction vector (x,y,z)\n// Returns: Complex value representing Y_l^m (real, imag)\nvec2 getYlmCartesian(int l, int m, vec3 dir) {\n    float x = dir.x;\n    float y = dir.y;\n    float z = dir.z;\n    float x2 = x*x;\n    float y2 = y*y;\n    float z2 = z*z;\n    \n    // Precompute common products\n    float xy = x*y;\n    float xz = x*z;\n    float yz = y*z;\n    float x2_y2 = x2 + y2;\n    \n    // L = 0\n    if (l == 0 && m == 0) {\n        // Y_0^0 = 1/(2*sqrt(pi))\n        return vec2(0.28209479177387814, 0.0);\n    }\n    \n    // L = 1\n    else if (l == 1) {\n        if (m == -1) {\n            // Y_1^-1 = sqrt(3/(4pi)) * y\n            return vec2(0.4886025119029199 * y, 0.0);\n        }\n        else if (m == 0) {\n            // Y_1^0 = sqrt(3/(4pi)) * z\n            return vec2(0.4886025119029199 * z, 0.0);\n        }\n        else if (m == 1) {\n            // Y_1^1 = -sqrt(3/(4pi)) * x\n            return vec2(0.4886025119029199 * x, 0.0);\n        }\n    }\n    \n    // L = 2\n    else if (l == 2) {\n        if (m == -2) {\n            // Y_2^-2 = 1/2 * sqrt(15/pi) * xy\n            return vec2(0.5462742152960395 * xy, 0.0);\n        }\n        else if (m == -1) {\n            // Y_2^-1 = 1/2 * sqrt(15/pi) * yz\n            return vec2(0.5462742152960395 * yz, 0.0);\n        }\n        else if (m == 0) {\n            // Y_2^0 = 1/4 * sqrt(5/pi) * (3z^2 - 1)\n            return vec2(0.31539156525252005 * (3.0*z2 - 1.0), 0.0);\n        }\n        else if (m == 1) {\n            // Y_2^1 = -1/2 * sqrt(15/pi) * xz\n            return vec2(0.5462742152960395 * xz, 0.0);\n        }\n        else if (m == 2) {\n            // Y_2^2 = 1/4 * sqrt(15/pi) * (x^2 - y^2)\n            return vec2(0.5462742152960395 * 0.5 * (x2 - y2), 0.0);\n        }\n    }\n    \n    // L = 3\n    else if (l == 3) {\n        if (m == -3) {\n            // Y_3^-3 = 1/4 * sqrt(35/(2pi)) * y(3x^2 - y^2)\n            return vec2(0.5900435899266435 * y * (3.0*x2 - y2), 0.0);\n        }\n        else if (m == -2) {\n            // Y_3^-2 = 1/2 * sqrt(105/pi) * xyz\n            return vec2(1.445305721320277 * xy * z, 0.0);\n        }\n        else if (m == -1) {\n            // Y_3^-1 = 1/4 * sqrt(21/(2pi)) * y(5z^2 - 1)\n            return vec2(0.6690465435572892 * y * (5.0*z2 - 1.0), 0.0);\n        }\n        else if (m == 0) {\n            // Y_3^0 = 1/4 * sqrt(7/pi) * z(5z^2 - 3)\n            return vec2(0.3731763325901154 * z * (5.0*z2 - 3.0), 0.0);\n        }\n        else if (m == 1) {\n            // Y_3^1 = -1/4 * sqrt(21/(2pi)) * x(5z^2 - 1)\n            return vec2(0.6690465435572892 * x * (5.0*z2 - 1.0), 0.0);\n        }\n        else if (m == 2) {\n            // Y_3^2 = 1/4 * sqrt(105/pi) * (x^2 - y^2)z\n            return vec2(1.445305721320277 * 0.5 * (x2 - y2) * z, 0.0);\n        }\n        else if (m == 3) {\n            // Y_3^3 = -1/4 * sqrt(35/(2pi)) * x(x^2 - 3y^2)\n            return vec2(0.5900435899266435 * x * (x2 - 3.0*y2), 0.0);\n        }\n    }\n    \n    // L = 4\n    else if (l == 4) {\n        if (m == -4) {\n            // Y_4^-4 = 3/4 * sqrt(35/pi) * xy(x^2 - y^2)\n            float x2_m_y2 = x2 - y2;\n            return vec2(0.6258357354491761 * xy * x2_m_y2, 0.0);\n        }\n        else if (m == -3) {\n            // Y_4^-3 = 3/4 * sqrt(35/(2pi)) * yz(3x^2 - y^2)\n            return vec2(0.9518580979661384 * yz * (3.0*x2 - y2), 0.0);\n        }\n        else if (m == -2) {\n            // Y_4^-2 = 3/4 * sqrt(5/pi) * xy(7z^2 - 1)\n            return vec2(0.5900435899266435 * xy * (7.0*z2 - 1.0), 0.0);\n        }\n        else if (m == -1) {\n            // Y_4^-1 = 3/4 * sqrt(5/(2pi)) * yz(7z^2 - 3)\n            return vec2(0.6258357354491761 * yz * (7.0*z2 - 3.0), 0.0);\n        }\n        else if (m == 0) {\n            // Y_4^0 = 3/16 * sqrt(1/pi) * (35z^4 - 30z^2 + 3)\n            return vec2(0.10578554691520431 * (35.0*z2*z2 - 30.0*z2 + 3.0), 0.0);\n        }\n        else if (m == 1) {\n            // Y_4^1 = -3/4 * sqrt(5/(2pi)) * xz(7z^2 - 3)\n            return vec2(0.6258357354491761 * xz * (7.0*z2 - 3.0), 0.0);\n        }\n        else if (m == 2) {\n            // Y_4^2 = 3/8 * sqrt(5/pi) * (x^2 - y^2)(7z^2 - 1)\n            return vec2(0.5900435899266435 * 0.5 * (x2 - y2) * (7.0*z2 - 1.0), 0.0);\n        }\n        else if (m == 3) {\n            // Y_4^3 = -3/4 * sqrt(35/(2pi)) * xz(x^2 - 3y^2)\n            return vec2(0.9518580979661384 * xz * (x2 - 3.0*y2), 0.0);\n        }\n        else if (m == 4) {\n            // Y_4^4 = 3/16 * sqrt(35/pi) * (x^4 - 6x^2y^2 + y^4)\n            float x4 = x2*x2;\n            float y4 = y2*y2;\n            return vec2(0.6258357354491761 * (x4 - 6.0*x2*y2 + y4), 0.0);\n        }\n    }\n    \n    // Fallback (should never happen if called with valid l, m)\n    return vec2(0.0, 0.0);\n}\n\n// Apply phase to complex number\nvec2 applyPhase(vec2 z, float phase) {\n    float cos_phase = cos(phase);\n    float sin_phase = sin(phase);\n    return vec2(\n        z.x * cos_phase - z.y * sin_phase,\n        z.x * sin_phase + z.y * cos_phase\n    );\n}\n\n// Simple radial function for visualization \nfloat radialFunction(float r, int n, int l) {\n    // Scale for visualization\n    float scale = 1.0;\n    float decay = 10.0;\n    \n    // Simple radial function with appropriate falloff\n    return scale * exp(-decay * r / float(n));\n}\n\n// Compute complete atomic orbital wavefunction\nvec2 hydrogenOrbitalOptimized(vec3 pos, int n, int l, int m, float phase) {\n    // Get length of position vector\n    float r = length(pos);\n    if (r < 0.001) return vec2(0.0); // Avoid division by zero\n    \n    // Normalize position to get direction\n    vec3 dir = pos / r;\n    \n    // Compute spherical harmonic using optimized Cartesian formula\n    vec2 ylm = getYlmCartesian(l, m, dir);\n    \n    float p = 2.0*length(pos)/float(n);\n    float radial = laguerre(p, float(n-l)-1., 2.*float(l)+1.);\n    radial *= exp(-p*.5)*pow(p, float(l));\n    vec2 result = ylm * radial * normalization(float(n), float(l));\n    // Apply phase and return complete wavefunction\n    return applyPhase(result, phase);\n}\n\n// Get combined wavefunction at a position (replacing the original function)\nvec2 getCombinedWavefunction(vec3 p) {\n    vec2 psi = vec2(0.0);\n    \n    // Compute the wavefunction for each orbital\n    for (int i = 0; i < 6; i++) { // Support for 6 orbitals\n        if (i >= orbital_count) break;\n        \n        float weight = orbital_weight[i];\n        if (weight > 0.001) {\n            vec2 orbitalPsi = hydrogenOrbitalOptimized(p, \n                                                      orbital_n[i], \n                                                      orbital_l[i], \n                                                      orbital_m[i], \n                                                      orbital_phase[i]);\n            psi += weight * orbitalPsi;\n        }\n    }\n    \n    return psi;\n}\n\n// Fast orbital color lookup\nvec3 getOrbitalColor(int l) {\n    // Colors for different angular momentum values\n    if (l == 0) return vec3(0.2, 0.5, 0.9);      // s: blue\n    if (l == 1) return vec3(1.0, 0.0, 0.0);      // p: red\n    if (l == 2) return vec3(0.0, 1.0, 0.0);      // d: green\n    if (l == 3) return vec3(1.0, 0.0, 1.0);      // f: purple\n    if (l == 4) return vec3(1.0, 1.0, 0.0);      // g: yellow\n    return vec3(0.5, 0.7, 0.7);                  // h+: teal\n}\n\n// Get mixed orbital color based on weights\nvec3 getMixedOrbitalColor() {\n    vec3 mixedColor = vec3(0.0);\n    float totalWeight = 0.0;\n    \n    // Sum all active orbital colors weighted by contribution\n    for (int i = 0; i < 6; i++) { // Support for 6 orbitals\n        if (i >= orbital_count) break;\n        \n        float weight = orbital_weight[i];\n        if (weight > 0.001) {\n            mixedColor += weight * getOrbitalColor(orbital_l[i]);\n            totalWeight += weight;\n        }\n    }\n    \n    return totalWeight > 0.0 ? mixedColor / totalWeight : vec3(0.5);\n}\n\n// Fast HSV to RGB conversion\nvec3 hsv2rgb(vec3 c) {\n    vec4 K = vec4(1.0, 2.0/3.0, 1.0/3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(vec3(1.0), clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n// Ray marching with efficient early termination\nvec4 raymarch(vec3 ro, vec3 rd) {\n    vec4 accum = vec4(0.0);\n    \n    // Calculate adaptive step size based on camera distance\n    float baseStepSize = STEP_SIZE;\n    float maxDistance = min(MAX_DISTANCE, 10.0 * length(cameraPos));\n    \n    // Ray-sphere intersection test for early culling\n    float b = dot(ro, rd);\n    float c = dot(ro, ro) - maxDistance * maxDistance;\n    float discriminant = b * b - c;\n    \n    if (discriminant < 0.0) return vec4(0.0); // Ray misses bounded sphere\n    \n    // Start ray at sphere entry if applicable\n    float t = -b - sqrt(discriminant);\n    if (t > 0.0) ro += rd * t;\n    \n    // Random offset to prevent banding\n    float offset = fract(sin(dot(vUv, vec2(12.9898, 78.233))) * 43758.5453);\n    vec3 p = ro + rd * baseStepSize * offset;\n    \n    // Rendering parameters\n    const float intensityScale = 12.0;\n    const float maxAlpha = 0.35;\n    const float densityBoost = 5.0;\n    \n    // Adaptive ray marching loop\n    for (int i = 0; i < MAX_STEPS; i++) {\n        // Skip if we're past the maximum distance\n        float dist = length(p);\n        if (dist > maxDistance) break;\n        \n        // Adaptive step size - larger steps in low-density regions\n        float adaptiveStep = baseStepSize * (1.0 + 0.3 * dist / 5.0);\n        \n        // Fast density estimation to skip low-density regions\n        float densityEstimate = exp(-dist * 0.5);\n        if (densityEstimate < 0.01) {\n            p += rd * adaptiveStep * 2.0;\n            continue;\n        }\n        \n        // Calculate wavefunction\n        vec2 psi = getCombinedWavefunction(p);\n        \n        // Calculate probability density\n        float density = dot(psi, psi) * densityBoost;\n        \n        // Skip low-density regions\n        if (density > DENSITY_THRESHOLD) {\n            // Extract real and imaginary parts\n            float realPart = psi.x;\n            float imagPart = psi.y;\n            \n            // Visualization variables\n            vec3 color;\n            float intensity;\n            \n            // Select visualization mode\n            if (renderMode == 0) {\n                // Probability density\n                color = getMixedOrbitalColor();\n                intensity = sqrt(density) * intensityScale;\n            }\n            else if (renderMode == 1) {\n                // Real component\n                color = realPart > 0.0 ? vec3(0.0, 0.8, 0.3) : vec3(0.9, 0.1, 0.2);\n                intensity = abs(realPart) * intensityScale;\n            }\n            else if (renderMode == 2) {\n                // Imaginary component\n                color = imagPart > 0.0 ? vec3(0.0, 0.8, 0.3) : vec3(0.9, 0.1, 0.2);\n                intensity = abs(imagPart) * intensityScale;\n            }\n            else if (renderMode == 3) {\n                // Phase visualization\n                float phase = atan(imagPart, realPart);\n                float hue = (phase + PI) / (2.0 * PI);\n                color = hsv2rgb(vec3(hue, 0.8, 0.9));\n                intensity = sqrt(density) * intensityScale;\n            }\n            else {\n                // Real/Imaginary mix\n                float realWeight = abs(realPart) / (abs(realPart) + abs(imagPart) + 0.0001);\n                vec3 realColor = realPart > 0.0 ? vec3(0.1, 0.5, 0.8) : vec3(0.7, 0.1, 0.2);\n                vec3 imagColor = imagPart > 0.0 ? vec3(0.9, 0.5, 0.1) : vec3(0.2, 0.7, 0.9);\n                color = mix(realColor, imagColor, 1.0 - realWeight);\n                intensity = density * intensityScale;\n            }\n            \n            // Soft edges\n            float boundaryFactor = smoothstep(edgeThreshold, edgeThreshold + edgeWidth, density);\n            boundaryFactor = boundaryFactor;\n            \n            // Alpha and compositing\n            float alpha = min(intensity * boundaryFactor, maxAlpha);\n            float depthFactor = 1.0 - clamp(length(p - ro) / maxDistance, 0.0, 1.0);\n            alpha *= mix(0.85, 1.3, depthFactor);\n            \n            // Create sample\n            vec4 samp = vec4(color * intensity * boundaryFactor, alpha);\n            samp.rgb *= samp.a;\n            \n            // Composite\n            accum.rgb += (1.0 - accum.a) * samp.rgb;\n            accum.a += (1.0 - accum.a) * samp.a;\n            \n            // Early termination if nearly opaque\n            if (accum.a > 0.98) break;\n        }\n        \n        // Step along ray\n        p += rd * adaptiveStep;\n    }\n    \n    // Tone mapping\n    accum.rgb = accum.rgb / (0.8 + accum.rgb);\n    accum.rgb = pow(accum.rgb, vec3(0.8)) * 1.7;\n    \n    return accum;\n}\n\nvoid main() {\n    // Generate ray\n    vec2 uv = vUv * 2.0 - 1.0;\n    uv.x *= aspectRatio;\n    \n    vec3 rayDirection = normalize(cameraDirection + uv.x * cameraRight + uv.y * cameraUp);\n    \n    // Perform ray marching\n    vec4 result = raymarch(cameraPos, rayDirection);\n    \n    // Background blend\n    vec3 backgroundColor = vec3(1.0);\n    vec3 finalColor = mix(backgroundColor, result.rgb, result.a);\n    \n    // Output\n    gl_FragColor = vec4(finalColor, 1.0);\n}",side:l.DoubleSide})}),[l,s,p]),u=()=>{if(!d.uniforms)return;d.uniforms.aspectRatio.value=i.width/i.height,d.uniforms.cameraPos.value.copy(n.position);const e=new l.Vector3(0,0,-1);e.applyQuaternion(n.quaternion),d.uniforms.cameraDirection.value.copy(e);const t=new l.Vector3(0,1,0);t.applyQuaternion(n.quaternion),d.uniforms.cameraUp.value.copy(t);const a=new l.Vector3(1,0,0);a.applyQuaternion(n.quaternion),d.uniforms.cameraRight.value.copy(a)};return(0,a.useEffect)((()=>{if(!d.uniforms)return;const n=p.map((n=>({n:n.n,l:n.l,m:n.m,weight:n.enabled?n.weight:0,phase:n.phase})));d.uniforms.orbital_n.value=n.map((n=>n.n)),d.uniforms.orbital_l.value=n.map((n=>n.l)),d.uniforms.orbital_m.value=n.map((n=>n.m)),d.uniforms.orbital_weight.value=n.map((n=>n.weight)),d.uniforms.orbital_phase.value=n.map((n=>n.phase)),d.uniforms.orbital_count.value=p.length,d.uniforms.renderMode.value=s,u()}),[d,p,s]),(0,r.C)(((n,e)=>{c.current&&(d.uniforms.time.value+=e,u())})),(0,o.jsxs)("mesh",{ref:c,frustumCulled:!1,children:[(0,o.jsx)("planeGeometry",{args:[2,2]})," ",(0,o.jsx)("primitive",{object:d,attach:"material"})]})};return(0,o.jsxs)("div",{style:{position:"relative",height:"500px"},children:[(0,o.jsxs)("div",{style:{position:"absolute",zIndex:10,padding:"10px",background:"rgba(0,0,0,0.7)",color:"white",borderRadius:"5px",maxHeight:"500px",overflowY:"auto",width:"300px"},children:[(0,o.jsxs)("div",{style:{marginBottom:"15px"},children:[(0,o.jsx)("h3",{style:{margin:"0 0 10px 0"},children:"Orbital Mixing"}),(0,o.jsxs)("div",{children:[(0,o.jsx)("button",{onClick:()=>{if(p.length<f){const n={n:1,l:0,m:0,weight:1,phase:0,enabled:!0};d([...p,n]),m(p.length)}},disabled:p.length>=f,style:{background:"#4CAF50",color:"white",border:"none",padding:"5px 10px",marginRight:"10px",borderRadius:"3px",cursor:p.length>=f?"not-allowed":"pointer",opacity:p.length>=f?.5:1},children:"Add Orbital"}),(0,o.jsx)("button",{onClick:()=>{const n=p.filter((n=>n.enabled));if(0===n.length)return;const e=n.reduce(((n,e)=>n+e.weight),0);if(e>0){const n=[...p];for(let t=0;t<n.length;t++)n[t].enabled&&(n[t].weight=n[t].weight/e);d(n)}},style:{background:"#2196F3",color:"white",border:"none",padding:"5px 10px",borderRadius:"3px",cursor:"pointer"},children:"Normalize Weights"})]})]}),p.map(((n,e)=>{return(0,o.jsxs)("div",{style:{marginBottom:"15px",padding:"10px",background:e===u?"rgba(255,255,255,0.1)":"transparent",borderRadius:"5px",border:"1px solid rgba(255,255,255,0.2)"},children:[(0,o.jsxs)("div",{style:{display:"flex",justifyContent:"space-between",alignItems:"center",marginBottom:"5px"},children:[(0,o.jsx)("strong",{style:{fontSize:"16px"},children:(t=n.n,i=n.l,a=n.m,`${t}${["s","p","d","f","g","h"][i]}${0!==a?` (m=${a})`:""}`)}),(0,o.jsxs)("div",{children:[(0,o.jsx)("button",{onClick:()=>m(e),style:{background:"transparent",color:"white",border:"1px solid white",padding:"2px 5px",marginRight:"5px",borderRadius:"3px",cursor:"pointer"},children:"Edit"}),(0,o.jsx)("button",{onClick:()=>(n=>{const e=[...p];e[n].enabled=!e[n].enabled,d(e)})(e),style:{background:n.enabled?"#4CAF50":"#f44336",color:"white",border:"none",padding:"2px 5px",marginRight:"5px",borderRadius:"3px",cursor:"pointer"},children:n.enabled?"On":"Off"}),p.length>1&&(0,o.jsx)("button",{onClick:()=>(n=>{if(p.length>1){const e=p.filter(((e,t)=>t!==n));d(e),u>=e.length?m(e.length-1):u===n&&m(Math.max(0,n-1))}})(e),style:{background:"#f44336",color:"white",border:"none",padding:"2px 5px",borderRadius:"3px",cursor:"pointer"},children:"\xd7"})]})]}),e===u&&(0,o.jsxs)("div",{children:[(0,o.jsxs)("div",{children:[(0,o.jsx)("label",{children:"n: "}),(0,o.jsx)("input",{type:"range",min:"1",max:"5",value:n.n,onChange:n=>h(e,"n",n.target.value)}),(0,o.jsx)("span",{children:n.n})]}),(0,o.jsxs)("div",{children:[(0,o.jsx)("label",{children:"l: "}),(0,o.jsx)("input",{type:"range",min:"0",max:n.n-1,value:n.l,onChange:n=>h(e,"l",n.target.value)}),(0,o.jsx)("span",{children:n.l})]}),(0,o.jsxs)("div",{children:[(0,o.jsx)("label",{children:"m: "}),(0,o.jsx)("input",{type:"range",min:-n.l,max:n.l,value:n.m,onChange:n=>h(e,"m",n.target.value)}),(0,o.jsx)("span",{children:n.m})]}),(0,o.jsxs)("div",{children:[(0,o.jsx)("label",{children:"Phase: "}),(0,o.jsx)("input",{type:"range",min:"0",max:"6.28",step:"0.01",value:n.phase,onChange:n=>h(e,"phase",n.target.value)}),(0,o.jsxs)("span",{children:[(n.phase/Math.PI).toFixed(2),"\u03c0"]})]})]}),(0,o.jsxs)("div",{children:[(0,o.jsx)("label",{children:"Weight: "}),(0,o.jsx)("input",{type:"range",min:"0",max:"1",step:"0.01",value:n.weight,disabled:!n.enabled,onChange:n=>h(e,"weight",n.target.value)}),(0,o.jsx)("span",{children:n.weight.toFixed(2)})]})]},e);var t,i,a})),(0,o.jsxs)("div",{style:{marginTop:"20px"},children:[(0,o.jsx)("label",{children:"Visualization: "}),(0,o.jsxs)("select",{value:s,onChange:n=>c(parseInt(n.target.value)),style:{background:"rgba(0,0,0,0.5)",color:"white",border:"1px solid #555",width:"100%",padding:"5px"},children:[(0,o.jsx)("option",{value:"0",children:"Probability Density"}),(0,o.jsx)("option",{value:"1",children:"Real Component"}),(0,o.jsx)("option",{value:"2",children:"Imaginary Component"}),(0,o.jsx)("option",{value:"3",children:"Phase"}),(0,o.jsx)("option",{value:"4",children:"Real/Imaginary Mix"})]})]})]}),(0,o.jsxs)(t,{camera:{position:[0,10,10],zoom:1.5,near:.1,far:1e3,orthographic:!0},style:{background:"#111",height:"500px"},children:[(0,o.jsx)("ambientLight",{intensity:.5}),(0,o.jsx)("pointLight",{position:[10,10,10]}),(0,o.jsx)(x,{}),(0,o.jsx)(i,{})]}),(0,o.jsxs)("div",{style:{position:"absolute",right:"10px",top:"10px",padding:"10px",background:"rgba(0,0,0,0.7)",color:"white",borderRadius:"5px",maxWidth:"250px",fontSize:"14px"},children:[(0,o.jsx)("h3",{style:{margin:"0 0 10px 0"},children:"Orbital Mixer"}),(0,o.jsx)("p",{children:"Mix up to 6 atomic orbitals to visualize quantum superpositions."}),(0,o.jsxs)("ul",{style:{paddingLeft:"20px",margin:"5px 0"},children:[(0,o.jsxs)("li",{children:["Use ",(0,o.jsx)("strong",{children:"Edit"})," to modify orbital parameters"]}),(0,o.jsxs)("li",{children:["Adjust ",(0,o.jsx)("strong",{children:"Weight"})," to control contribution"]}),(0,o.jsxs)("li",{children:["Toggle orbitals ",(0,o.jsx)("strong",{children:"On/Off"})," with the button"]}),(0,o.jsxs)("li",{children:["Use ",(0,o.jsx)("strong",{children:"Phase"})," to control quantum phase"]}),(0,o.jsxs)("li",{children:["Click ",(0,o.jsx)("strong",{children:"Normalize"})," to balance weights"]})]}),(0,o.jsx)("p",{children:"Try mixing s and p orbitals to create hybrid orbitals, or explore complex superpositions!"})]})]})},s=()=>{const[n,e]=(0,a.useState)(!1),[i,r]=(0,a.useState)(null);return(0,a.useEffect)((()=>{(async()=>{try{const n=await Promise.resolve().then(t.bind(t,9437)),i=await t.e(2428).then(t.bind(t,2428)),a=await t.e(5276).then(t.bind(t,5276));r({Canvas:i.Canvas,OrbitControls:a.OrbitControls,THREE:n}),e(!0)}catch(n){console.error("Failed to load Three.js libraries:",n)}})()}),[]),n&&i?(0,o.jsx)(l,{Components:i}):(0,o.jsx)("div",{children:"Loading 3D visualization..."})};function c(){return(0,o.jsx)(i.A,{title:"Quantum Mechanics Visualizations",description:"Interactive visualizations of quantum mechanics concepts",children:(0,o.jsxs)("main",{children:[(0,o.jsx)("h2",{children:"Hydrogenic orbitals"}),(0,o.jsx)(s,{})]})})}}}]);
(()=>{var e={},t={};function s(a){var o=t[a];if(void 0!==o)return o.exports;var r=t[a]={exports:{}};return e[a](r,r.exports,s),r.exports}s.m=e,s.d=(e,t)=>{for(var a in t)s.o(t,a)&&!s.o(e,a)&&Object.defineProperty(e,a,{enumerable:!0,get:t[a]})},s.f={},s.e=e=>Promise.all(Object.keys(s.f).reduce(((t,a)=>(s.f[a](e,t),t)),[])),s.u=e=>"assets/js/"+e+".631587d1.js",s.miniCssF=e=>{},s.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t),s.r=e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},s.p="/",s.gca=function(e){return e={}[e]||e,s.p+s.u(e)},(()=>{s.b=self.location+"/../../../";var e={842:1};s.f.i=(t,a)=>{e[t]||importScripts(s.p+s.u(t))};var t=self.webpackChunkblog=self.webpackChunkblog||[],a=t.push.bind(t);t.push=t=>{var o=t[0],r=t[1],l=t[2];for(var n in r)s.o(r,n)&&(s.m[n]=r[n]);for(l&&l(s);o.length;)e[o.pop()]=1;a(t)}})();let a=null,o=null;self.addEventListener("message",(async function(e){const{type:t,data:r}=e.data;try{switch(t){case"init":await async function(){try{postMessage({type:"log",level:2,message:"Initializing OCC in worker..."});try{a=await s.e(9819).then(s.bind(s,9819)),postMessage({type:"log",level:2,message:"Loaded OCC package"})}catch(e){return void postMessage({type:"initialized",success:!1,error:`OCC package import failed: ${e.message}. The WASM module contains Node.js-specific imports that don't work in browsers.`})}o=await a.loadOCC(),o.registerLogCallback&&o.registerLogCallback(((e,t)=>{postMessage({type:"log",level:e,message:t})})),postMessage({type:"initialized",success:!0})}catch(t){postMessage({type:"initialized",success:!1,error:t.message})}}();break;case"calculate":await async function(t){try{const o=performance.now();postMessage({type:"progress",stage:"start",message:"Starting calculation..."}),postMessage({type:"log",level:2,message:"Creating molecule from XYZ data..."});const r=await a.moleculeFromXYZ(t.xyzData);postMessage({type:"log",level:2,message:`Molecule created: ${r.size()} atoms`}),postMessage({type:"progress",stage:"setup",message:`Setting up ${t.method.toUpperCase()} calculation with ${t.basisSet} basis...`});const l=await a.createQMCalculation(r,t.basisSet),n=(new a.SCFSettings).setMaxIterations(t.maxIterations).setEnergyTolerance(t.energyTolerance);let c;if(postMessage({type:"progress",stage:"calculation",message:"Running SCF iterations..."}),"hf"===t.method)postMessage({type:"log",level:2,message:"Running Hartree-Fock calculation..."}),c=await l.runHF(n);else if(t.method.startsWith("dft-")){const e=t.method.substring(4);postMessage({type:"log",level:2,message:`Running DFT calculation with ${e} functional...`}),c=await l.runDFT(e,{scfSettings:n})}const i=performance.now()-o;postMessage({type:"progress",stage:"complete",message:"Calculation completed successfully!"});const g={energy:c,energyInEV:27.2114*c,elapsedMs:i,converged:!0};try{const e=await l.calculateProperties(["orbitals","homo","lumo","gap"]);g.properties={homo:e.homo,lumo:e.lumo,gap:e.gap}}catch(e){postMessage({type:"log",level:3,message:`Could not calculate properties: ${e.message}`})}try{const e=l.wavefunction;g.wavefunctionData={numBasisFunctions:l.basis.nbf(),numAtoms:r.size(),nAlpha:e.nAlpha||Math.ceil(r.numElectrons()/2),nBeta:e.nBeta||Math.floor(r.numElectrons()/2),numElectrons:r.numElectrons(),basisSet:t.basisSet,method:t.method};try{postMessage({type:"log",level:2,message:"Generating FCHK file..."});const t=e.exportToString("fchk");if(!(t&&t.length>0))throw new Error("FCHK string is empty or null");g.wavefunctionData.fchk=t,postMessage({type:"log",level:2,message:"FCHK file generated successfully"})}catch(s){postMessage({type:"log",level:3,message:`Could not generate FCHK file: ${s.message}`})}self.currentCalculation=l,self.currentMolecule=r}catch(e){postMessage({type:"log",level:3,message:`Could not store wavefunction data: ${e.message}`})}postMessage({type:"progress",stage:"matrices",message:"Computing matrices..."}),g.matrices={};try{const t=new(a.getModule().HartreeFock)(l.basis),s=l.wavefunction,o=e=>{const t=e.rows(),s=e.cols(),a=[];for(let o=0;o<t;o++){const t=[];for(let a=0;a<s;a++)t.push(e.get(o,a));a.push(t)}return{rows:t,cols:s,data:a}};postMessage({type:"log",level:2,message:"Computing overlap matrix..."});try{const e=t.overlapMatrix();g.matrices.overlap=o(e)}catch(e){postMessage({type:"log",level:3,message:`Could not compute overlap matrix: ${e.message}`})}postMessage({type:"log",level:2,message:"Computing kinetic energy matrix..."});try{const e=t.kineticMatrix();g.matrices.kinetic=o(e)}catch(e){postMessage({type:"log",level:3,message:`Could not compute kinetic matrix: ${e.message}`})}postMessage({type:"log",level:2,message:"Computing nuclear attraction matrix..."});try{const e=t.nuclearAttractionMatrix();g.matrices.nuclear=o(e)}catch(e){postMessage({type:"log",level:3,message:`Could not compute nuclear attraction matrix: ${e.message}`})}postMessage({type:"log",level:2,message:"Computing Fock matrix..."});try{const e=t.fockMatrix(s.molecularOrbitals);g.matrices.fock=o(e)}catch(e){postMessage({type:"log",level:3,message:`Could not compute Fock matrix: ${e.message}`})}postMessage({type:"log",level:2,message:"Extracting density matrix..."});try{const e=s.molecularOrbitals.densityMatrix;g.matrices.density=o(e)}catch(e){postMessage({type:"log",level:3,message:`Could not extract density matrix: ${e.message}`})}postMessage({type:"log",level:2,message:"Extracting MO coefficients..."});try{const e=s.coefficients();g.matrices.coefficients=o(e)}catch(e){postMessage({type:"log",level:3,message:`Could not extract MO coefficients: ${e.message}`})}try{const e=s.orbitalEnergies(),t=[];for(let s=0;s<e.size();s++)t.push(e.get(s));g.orbitalEnergies=t}catch(e){postMessage({type:"log",level:3,message:`Could not extract orbital energies: ${e.message}`})}try{const e=g.orbitalEnergies?g.orbitalEnergies.length:0;if(e>0){const t=[],a=s.nAlpha||Math.ceil(r.numElectrons()/2),o=s.nBeta||Math.floor(r.numElectrons()/2);for(let s=0;s<e;s++)s<Math.min(a,o)?t.push(2):s<Math.max(a,o)?t.push(1):t.push(0);g.orbitalOccupations=t}}catch(e){postMessage({type:"log",level:3,message:`Could not extract orbital occupations: ${e.message}`})}}catch(e){postMessage({type:"log",level:3,message:`Matrix computation failed: ${e.message}`})}postMessage({type:"result",success:!0,results:g})}catch(o){postMessage({type:"result",success:!1,error:o.message})}}(r);break;case"setLogLevel":l=r.level,o&&o.setLogLevel&&(o.setLogLevel(l),postMessage({type:"log",level:2,message:`Log level set to ${l}`}));break;case"computeCube":await async function(e){try{const a=performance.now();if(postMessage({type:"log",level:2,message:`Computing ${e.cubeType} cube for orbital ${e.orbitalIndex||"N/A"}...`}),!self.currentCalculation||!self.currentMolecule)throw new Error("No calculation available. Please run a calculation first.");const r=self.currentCalculation.wavefunction;let l;switch(e.cubeType){case"molecular_orbital":try{l=o.generateMOCube(r,e.orbitalIndex,e.gridSteps||40,e.gridSteps||40,e.gridSteps||40)}catch(t){postMessage({type:"log",level:3,message:`Simple MO cube generation failed, trying volume calculator: ${t.message}`});const s=new o.VolumeCalculator;s.setWavefunction(r);const a=new o.VolumeGenerationParameters;a.property=o.VolumePropertyKind.MolecularOrbital,a.orbitalIndex=e.orbitalIndex,a.setSteps(e.gridSteps||40,e.gridSteps||40,e.gridSteps||40),e.gridBuffer&&a.setBuffer(e.gridBuffer);const n=s.computeVolume(a);l=s.volumeAsCubeString(n),n.delete(),a.delete(),s.delete()}break;case"electron_density":l=o.generateElectronDensityCube(r,e.gridSteps||40,e.gridSteps||40,e.gridSteps||40);break;case"electric_potential":try{const t=new o.VolumeCalculator;t.setWavefunction(r);const s=new o.VolumeGenerationParameters;s.property=o.VolumePropertyKind.ElectricPotential,s.setSteps(e.gridSteps||40,e.gridSteps||40,e.gridSteps||40),e.gridBuffer&&s.setBuffer(e.gridBuffer);const a=t.computeVolume(s);l=t.volumeAsCubeString(a),a.delete(),s.delete(),t.delete()}catch(s){throw postMessage({type:"log",level:3,message:`ESP calculation failed: ${s.message}`}),s}break;default:throw new Error(`Unknown cube type: ${e.cubeType}`)}const n=performance.now()-a;postMessage({type:"log",level:2,message:`Cube computation completed in ${n.toFixed(0)}ms`}),postMessage({type:"cubeResult",success:!0,cubeData:l,cubeType:e.cubeType,orbitalIndex:e.orbitalIndex,gridSteps:e.gridSteps,gridBuffer:e.gridBuffer,elapsedMs:n})}catch(a){postMessage({type:"cubeResult",success:!1,error:a.message,cubeType:e.cubeType,orbitalIndex:e.orbitalIndex})}}(r);break;default:postMessage({type:"error",error:`Unknown message type: ${t}`})}}catch(n){postMessage({type:"error",error:n.message||"Unknown error occurred",stack:n.stack})}var l}))})();
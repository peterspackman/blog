(()=>{var e,s,t,a,o,i,n,r={},l={};function c(e){var s=l[e];if(void 0!==s)return s.exports;var t=l[e]={exports:{}};return r[e](t,t.exports,c),t.exports}c.m=r,e="function"==typeof Symbol,s=e?Symbol("webpack queues"):"__webpack_queues__",t=e?Symbol("webpack exports"):"__webpack_exports__",a=e?Symbol("webpack error"):"__webpack_error__",o=e=>{e&&e.d<1&&(e.d=1,e.forEach(e=>e.r--),e.forEach(e=>e.r--?e.r++:e()))},c.a=(e,i,n)=>{var r;n&&((r=[]).d=-1);var l,c,u,p=new Set,M=e.exports,g=new Promise((e,s)=>{u=s,c=e});g[t]=M,g[s]=e=>(r&&e(r),p.forEach(e),g.catch(e=>{})),e.exports=g,i(e=>{var i;l=(e=>e.map(e=>{if(null!==e&&"object"==typeof e){if(e[s])return e;if(e.then){var i=[];i.d=0,e.then(e=>{n[t]=e,o(i)},e=>{n[a]=e,o(i)});var n={};return n[s]=e=>e(i),n}}var r={};return r[s]=e=>{},r[t]=e,r}))(e);var n=()=>l.map(e=>{if(e[a])throw e[a];return e[t]}),c=new Promise(e=>{(i=()=>e(n)).r=0;var t=e=>e!==r&&!p.has(e)&&(p.add(e),e&&!e.d&&(i.r++,e.push(i)));l.map(e=>e[s](t))});return i.r?c:n()},e=>(e?u(g[a]=e):c(M),o(r))),r&&r.d<0&&(r.d=0)},n=Object.getPrototypeOf?e=>Object.getPrototypeOf(e):e=>e.__proto__,c.t=function(e,s){if(1&s&&(e=this(e)),8&s)return e;if("object"==typeof e&&e){if(4&s&&e.__esModule)return e;if(16&s&&"function"==typeof e.then)return e}var t=Object.create(null);c.r(t);var a={};i=i||[null,n({}),n([]),n(n)];for(var o=2&s&&e;("object"==typeof o||"function"==typeof o)&&!~i.indexOf(o);o=n(o))Object.getOwnPropertyNames(o).forEach(s=>a[s]=()=>e[s]);return a.default=()=>e,c.d(t,a),t},c.d=(e,s)=>{for(var t in s)c.o(s,t)&&!c.o(e,t)&&Object.defineProperty(e,t,{enumerable:!0,get:s[t]})},c.f={},c.e=e=>Promise.all(Object.keys(c.f).reduce((s,t)=>(c.f[t](e,s),s),[])),c.u=e=>"assets/js/"+e+"."+{2987:"12768efc",6719:"62e49840",9184:"31ba1f45"}[e]+".js",c.miniCssF=e=>{},c.o=(e,s)=>Object.prototype.hasOwnProperty.call(e,s),c.r=e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},c.p="/",c.gca=function(e){return e={}[e]||e,c.p+c.u(e)},(()=>{c.b=self.location+"/../../../";var e={9761:1};c.f.i=(s,t)=>{e[s]||importScripts(c.p+c.u(s))};var s=globalThis.webpackChunkblog=globalThis.webpackChunkblog||[],t=s.push.bind(s);s.push=s=>{var[a,o,i]=s;for(var n in o)c.o(o,n)&&(c.m[n]=o[n]);for(i&&i(c);a.length;)e[a.pop()]=1;t(s)}})();let u=null,p=null;function M(e){const s=[];for(let o=0;o<50;o++)for(let e=0;e<50;e++){const t=o/50*Math.PI,a=e/50*2*Math.PI,i=Math.sin(t)*Math.cos(a),n=Math.sin(t)*Math.sin(a),r=Math.cos(t);if(Math.abs(i)>1e-10||Math.abs(n)>1e-10||Math.abs(r)>1e-10){const e=Math.sqrt(i*i+n*n+r*r);s.push(p.Vec3.create(i/e,n/e,r/e))}}const t={youngsModulus:{min:1/0,max:-1/0},linearCompressibility:{min:1/0,max:-1/0},shearModulus:{min:1/0,max:-1/0},poissonRatio:{min:1/0,max:-1/0}};for(const o of s)try{const s=e.youngsModulus(o);t.youngsModulus.min=Math.min(t.youngsModulus.min,s),t.youngsModulus.max=Math.max(t.youngsModulus.max,s);const a=e.linearCompressibility(o);t.linearCompressibility.min=Math.min(t.linearCompressibility.min,a),t.linearCompressibility.max=Math.max(t.linearCompressibility.max,a);const i=e.shearModulusMinMax(o);i&&(t.shearModulus.min=Math.min(t.shearModulus.min,i.min),t.shearModulus.max=Math.max(t.shearModulus.max,i.max));const n=e.poissonRatioMinMax(o);n&&(t.poissonRatio.min=Math.min(t.poissonRatio.min,n.min),t.poissonRatio.max=Math.max(t.poissonRatio.max,n.max))}catch(a){}return t.youngsModulus.anisotropy=t.youngsModulus.max/t.youngsModulus.min,t.linearCompressibility.anisotropy=t.linearCompressibility.max/t.linearCompressibility.min,t.shearModulus.anisotropy=t.shearModulus.max/t.shearModulus.min,t.poissonRatio.min>=0?t.poissonRatio.anisotropy=t.poissonRatio.max/t.poissonRatio.min:t.poissonRatio.max<=0?t.poissonRatio.anisotropy=t.poissonRatio.min/t.poissonRatio.max:t.poissonRatio.anisotropy=1/0,t}function g(e,s,t,a=180){const o=[];for(let n=0;n<=a;n++){const r=n/a*2*Math.PI;let l,c,u;"xy"===t?(l=Math.cos(r),c=Math.sin(r),u=0):"xz"===t?(l=Math.cos(r),c=0,u=Math.sin(r)):"yz"===t&&(l=0,c=Math.cos(r),u=Math.sin(r));const M=p.Vec3.create(l,c,u);let g=0,m=0,h=0;try{if("youngs"===s)g=e.youngsModulus(M),m=h=g;else if("linear_compressibility"===s)g=e.linearCompressibility(M),m=h=g;else if("shear"===s){const s=e.shearModulusMinMax(M);m=s.min,h=s.max,g=h}else if("poisson"===s){const s=e.poissonRatioMinMax(M);m=s.min,h=s.max,g=h}}catch(i){g=m=h=0}o.push({angle:180*r/Math.PI,angleRad:r,value:g,valueMin:m,valueMax:h})}return o}function m(e,s){const t=[];for(let i=0;i<=120;i++){const a=[];for(let t=0;t<=60;t++){const n=i/120*2*Math.PI,r=t/60*Math.PI,l=Math.sin(r)*Math.cos(n),c=Math.sin(r)*Math.sin(n),u=Math.cos(r),M=p.Vec3.create(l,c,u);let g=0;try{if("youngs"===s)g=e.youngsModulus(M);else if("linear_compressibility"===s)g=e.linearCompressibility(M);else if("shear"===s){const s=e.shearModulusMinMax(M);g=s?s.max:0}else if("poisson"===s){const s=e.poissonRatioMinMax(M);g=s?s.max:0}}catch(o){g=0}a.push(g)}t.push(a)}const a=t.flat();return{surfaceData:t,minValue:Math.min(...a),maxValue:Math.max(...a),property:s,numU:121,numV:61}}self.addEventListener("message",async function(e){const{type:s,data:t}=e.data;try{switch(s){case"init":await async function(){try{postMessage({type:"log",level:2,message:"Initializing OCC in worker..."});try{u=await c.e(9184).then(c.bind(c,9184)),postMessage({type:"log",level:2,message:"Loaded OCC package"})}catch(e){return void postMessage({type:"initialized",success:!1,error:`OCC package import failed: ${e.message}. The WASM module contains Node.js-specific imports that don't work in browsers.`})}p=await u.loadOCC(),p.registerLogCallback&&p.registerLogCallback((e,s)=>{postMessage({type:"log",level:e,message:s})}),postMessage({type:"initialized",success:!0})}catch(s){postMessage({type:"initialized",success:!1,error:s.message})}}();break;case"analyzeAll":await async function(e){try{const{tensors:t,properties:a=["youngs","linear_compressibility","shear","poisson"]}=e;postMessage({type:"log",level:2,message:`Starting comprehensive analysis for ${t.length} tensor(s)...`});const o=[];for(let e=0;e<t.length;e++){const i=t[e].data,n=t[e].id||e;let r;r=p.Mat6&&p.Mat6.create?p.Mat6.create(6,6):p.Mat.create(6,6);for(let e=0;e<6;e++)for(let s=0;s<6;s++)r.set(e,s,i[e][s]);const l=new p.ElasticTensor(r),c=[p.AveragingScheme.VOIGT,p.AveragingScheme.REUSS,p.AveragingScheme.HILL],u=["voigt","reuss","hill"],h={bulkModulus:{},shearModulus:{},youngsModulus:{},poissonRatio:{},linearCompressibility:{}};for(let e=0;e<c.length;e++){const s=c[e],t=u[e];h.bulkModulus[t]=l.averageBulkModulus(s),h.shearModulus[t]=l.averageShearModulus(s),h.youngsModulus[t]=l.averageYoungsModulus(s),h.poissonRatio[t]=l.averagePoissonRatio(s),h.linearCompressibility[t]=1e3/h.bulkModulus[t]}let y=null,f=!0,d=null;try{if(l.eigenvalues&&"function"==typeof l.eigenvalues){const e=l.eigenvalues();if(y=[],e&&e.size&&"function"==typeof e.size)for(let s=0;s<e.size();s++)y.push(e.get(s));else if(e&&void 0!==e.length)for(let s=0;s<e.length;s++)y.push(e[s]);else Array.isArray(e)&&(y=[...e]);y.sort((e,s)=>e-s),f=y.every(e=>e>0)}}catch(s){d=s.message,y=null}const v=M(l),x={},b=["xy","xz","yz"];for(const e of b){x[e]={};for(const s of a)x[e][s]=g(l,s,e,180)}const R={};for(const e of a)R[e]=m(l,e);const C=[],k=[],w=l.voigtC;for(let e=0;e<6;e++){const s=[];for(let t=0;t<6;t++)s.push(w.get(e,t));C.push(s)}const S=l.voigtS;for(let e=0;e<6;e++){const s=[];for(let t=0;t<6;t++)s.push(S.get(e,t));k.push(s)}o.push({id:n,properties:h,eigenvalues:y,eigenvalueError:d,isPositiveDefinite:f,extrema:v,directionalData:x,surfaceData:R,stiffnessMatrix:C,complianceMatrix:k})}postMessage({type:"analyzeAllResult",success:!0,data:o}),postMessage({type:"log",level:2,message:"Comprehensive analysis complete"})}catch(s){postMessage({type:"analyzeAllResult",success:!1,error:s.message})}}(t);break;case"analyzeTensor":await async function(s){try{postMessage({type:"log",level:2,message:"Starting elastic tensor analysis..."});const{tensorData:a}=s;let o;o=p.Mat6&&p.Mat6.create?p.Mat6.create(6,6):p.Mat.create(6,6);for(let e=0;e<6;e++)for(let s=0;s<6;s++)o.set(e,s,a[e][s]);const i=new p.ElasticTensor(o),n=[p.AveragingScheme.VOIGT,p.AveragingScheme.REUSS,p.AveragingScheme.HILL],r=["voigt","reuss","hill"],l={bulkModulus:{},shearModulus:{},youngsModulus:{},poissonRatio:{},linearCompressibility:{}};for(let e=0;e<n.length;e++){const s=n[e],t=r[e];l.bulkModulus[t]=i.averageBulkModulus(s),l.shearModulus[t]=i.averageShearModulus(s),l.youngsModulus[t]=i.averageYoungsModulus(s),l.poissonRatio[t]=i.averagePoissonRatio(s),l.linearCompressibility[t]=1e3/l.bulkModulus[t]}let c=null,u=!0,M=null;try{if(!i.eigenvalues||"function"!=typeof i.eigenvalues)throw new Error("eigenvalues() method not available in ElasticTensor");{const e=i.eigenvalues();if(c=[],e&&e.size&&"function"==typeof e.size)for(let s=0;s<e.size();s++)c.push(e.get(s));else if(e&&void 0!==e.length)for(let s=0;s<e.length;s++)c.push(e[s]);else{if(!Array.isArray(e))throw new Error("Unknown eigenvalue result format");c=[...e]}if(c.sort((e,s)=>e-s),u=c.every(e=>e>0),postMessage({type:"log",level:2,message:`Retrieved ${c.length} eigenvalues: [${c.map(e=>e.toFixed(4)).join(", ")}]`}),!u){const e=c.filter(e=>e<=0).length;postMessage({type:"log",level:1,message:`Warning: Tensor is not positive definite - ${e} eigenvalue(s) <= 0`})}}}catch(t){M=t.message,c=null,u=!0,postMessage({type:"log",level:1,message:`Could not calculate eigenvalues: ${t.message}`})}const g=50,m=[];for(let e=0;e<g;e++)for(let s=0;s<g;s++){const t=e/g*Math.PI,a=s/g*2*Math.PI,o=Math.sin(t)*Math.cos(a),i=Math.sin(t)*Math.sin(a),n=Math.cos(t);m.push(p.Vec3.create(o,i,n))}let h=1/0,y=-1/0,f=1/0,d=-1/0,v=1/0,x=-1/0,b=1/0,R=-1/0;m.forEach(s=>{try{const t=i.youngsModulus(s);h=Math.min(h,t),y=Math.max(y,t);const a=i.linearCompressibility(s);f=Math.min(f,a),d=Math.max(d,a);try{const e=i.shearModulusMinMax(s);e&&(v=Math.min(v,e.min),x=Math.max(x,e.max))}catch(e){const a=t/2.6;v=Math.min(v,a),x=Math.max(x,a)}try{const e=i.poissonRatioMinMax(s);e&&(b=Math.min(b,e.min),R=Math.max(R,e.max))}catch(e){const a=t/(t/3*2)-1;b=Math.min(b,Math.max(-1,a)),R=Math.max(R,Math.min(.5,a))}}catch(e){postMessage({type:"log",level:1,message:`Warning: Could not calculate property for direction: ${e.message}`})}});const C={shearModulus:{min:v,max:x,anisotropy:x/v},youngsModulus:{min:h,max:y,anisotropy:y/h},poissonRatio:{min:b,max:R,anisotropy:Math.abs(R/b)},linearCompressibility:{min:f,max:d,anisotropy:d/f}},k=[],w=[],S=i.voigtC,P=i.voigtS;for(let e=0;e<6;e++){const s=[],t=[];for(let a=0;a<6;a++)s.push(S.get(e,a)),t.push(P.get(e,a));k.push(s),w.push(t)}postMessage({type:"analysisResult",success:!0,data:{properties:l,eigenvalues:c,eigenvalueError:M,isPositiveDefinite:u,extrema:C,stiffnessMatrix:k,complianceMatrix:w,elasticTensor:i}}),postMessage({type:"log",level:2,message:"Elastic tensor analysis complete"})}catch(t){postMessage({type:"analysisResult",success:!1,error:t.message})}}(t);break;case"generateDirectionalData":await async function(s){try{const{tensorData:t,property:a,plane:o,numPoints:i,isReference:n}=s;let r;postMessage({type:"log",level:2,message:`Generating directional data for ${a} ${o} (ref: ${n})...`}),r=p.Mat6&&p.Mat6.create?p.Mat6.create(6,6):p.Mat.create(6,6);for(let e=0;e<6;e++)for(let s=0;s<6;s++)r.set(e,s,t[e][s]);const l=new p.ElasticTensor(r);if(l.generateDirectionalData)try{const e=l.generateDirectionalData(a,i||180),s=[];for(let t=0;t<e.size();t++){const a=e.get(t);let i=a.x,n=a.y;if("xz"===o){const e=n;n=0,n=e}else if("yz"===o){const e=i;i=n,n=e}s.push({angle:180*a.angle/Math.PI,angleRad:a.angle,value:a.value,valueMin:a.value,valueMax:a.value,x:i,y:n})}return postMessage({type:"directionalDataResult",success:!0,data:s,plane:o,isReference:n||!1}),void postMessage({type:"log",level:2,message:"Directional data generation complete (WASM)"})}catch(e){postMessage({type:"log",level:1,message:`WASM method failed, using fallback: ${e.message}`})}const c=[];for(let s=0;s<=i;s++){const t=s/i*2*Math.PI;let n;n="xy"===o?p.Vec3.create(Math.cos(t),Math.sin(t),0):"xz"===o?p.Vec3.create(Math.cos(t),0,Math.sin(t)):p.Vec3.create(0,Math.cos(t),Math.sin(t));let r=0,u=0,M=0;try{if("youngs"===a)r=l.youngsModulus(n),u=M=r;else if("linear_compressibility"===a)r=l.linearCompressibility(n),u=M=r;else if("shear"===a){const e=l.shearModulusMinMax(n);u=e.min,M=e.max,r=M}else if("poisson"===a){const e=l.poissonRatioMinMax(n);u=e.min,M=e.max,r=M}}catch(e){r=u=M=0}c.push({angle:180*t/Math.PI,angleRad:t,value:r,valueMin:u,valueMax:M})}postMessage({type:"directionalDataResult",success:!0,data:c,plane:o,isReference:n||!1}),postMessage({type:"log",level:2,message:"Directional data generation complete"})}catch(t){postMessage({type:"directionalDataResult",success:!1,error:t.message})}}(t);break;case"generate3DSurfaceData":await async function(s){try{const{tensorData:t,property:a,isReference:o}=s;let i;postMessage({type:"log",level:2,message:`Generating 3D surface data for ${a}...`}),i=p.Mat6&&p.Mat6.create?p.Mat6.create(6,6):p.Mat.create(6,6);for(let e=0;e<6;e++)for(let s=0;s<6;s++)i.set(e,s,t[e][s]);const n=new p.ElasticTensor(i),r=120,l=60,c=[];for(let s=0;s<=r;s++){const t=[];for(let o=0;o<=l;o++){const i=s/r*2*Math.PI,c=o/l*Math.PI,u=Math.sin(c)*Math.cos(i),M=Math.sin(c)*Math.sin(i),g=Math.cos(c),m=p.Vec3.create(u,M,g);let h=0;try{if("youngs"===a)h=n.youngsModulus(m);else if("linear_compressibility"===a)h=n.linearCompressibility(m);else if("shear"===a){const e=n.shearModulusMinMax(m);h=e?e.max:0}else if("poisson"===a){const e=n.poissonRatioMinMax(m);h=e?e.max:0}}catch(e){h=0}t.push(h)}c.push(t)}const u=c.flat(),M=Math.min(...u),g=Math.max(...u);postMessage({type:"3DSurfaceResult",success:!0,data:{surfaceData:c,minValue:M,maxValue:g,property:a,numU:r+1,numV:l+1},isReference:o||!1}),postMessage({type:"log",level:2,message:"3D surface data generation complete"})}catch(t){postMessage({type:"3DSurfaceResult",success:!1,error:t.message})}}(t);break;default:postMessage({type:"error",error:`Unknown message type: ${s}`})}}catch(a){postMessage({type:"error",error:a.message||"Unknown error occurred",stack:a.stack})}})})();
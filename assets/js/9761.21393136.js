(()=>{var e={},s={};function a(t){var o=s[t];if(void 0!==o)return o.exports;var n=s[t]={exports:{}};return e[t](n,n.exports,a),n.exports}a.m=e,a.d=(e,s)=>{for(var t in s)a.o(s,t)&&!a.o(e,t)&&Object.defineProperty(e,t,{enumerable:!0,get:s[t]})},a.f={},a.e=e=>Promise.all(Object.keys(a.f).reduce(((s,t)=>(a.f[t](e,s),s)),[])),a.u=e=>"assets/js/"+e+".631587d1.js",a.miniCssF=e=>{},a.o=(e,s)=>Object.prototype.hasOwnProperty.call(e,s),a.r=e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},a.p="/",a.gca=function(e){return e={}[e]||e,a.p+a.u(e)},(()=>{a.b=self.location+"/../../../";var e={9761:1};a.f.i=(s,t)=>{e[s]||importScripts(a.p+a.u(s))};var s=self.webpackChunkblog=self.webpackChunkblog||[],t=s.push.bind(s);s.push=s=>{var o=s[0],n=s[1],r=s[2];for(var i in n)a.o(n,i)&&(a.m[i]=n[i]);for(r&&r(a);o.length;)e[o.pop()]=1;t(s)}})();let t=null,o=null;self.addEventListener("message",(async function(e){const{type:s,data:n}=e.data;try{switch(s){case"init":await async function(){try{postMessage({type:"log",level:2,message:"Initializing OCC in worker..."});try{t=await a.e(9819).then(a.bind(a,9819)),postMessage({type:"log",level:2,message:"Loaded OCC package"})}catch(e){return void postMessage({type:"initialized",success:!1,error:`OCC package import failed: ${e.message}. The WASM module contains Node.js-specific imports that don't work in browsers.`})}o=await t.loadOCC(),o.registerLogCallback&&o.registerLogCallback(((e,s)=>{postMessage({type:"log",level:e,message:s})})),postMessage({type:"initialized",success:!0})}catch(s){postMessage({type:"initialized",success:!1,error:s.message})}}();break;case"analyzeTensor":await async function(s){try{postMessage({type:"log",level:2,message:"Starting elastic tensor analysis..."});const{tensorData:a}=s;let t;t=o.Mat6&&o.Mat6.create?o.Mat6.create(6,6):o.Mat.create(6,6);for(let e=0;e<6;e++)for(let s=0;s<6;s++)t.set(e,s,a[e][s]);const n=new o.ElasticTensor(t),r=[o.AveragingScheme.VOIGT,o.AveragingScheme.REUSS,o.AveragingScheme.HILL],i=["voigt","reuss","hill"],l={bulkModulus:{},shearModulus:{},youngsModulus:{},poissonRatio:{},linearCompressibility:{}};for(let e=0;e<r.length;e++){const s=r[e],a=i[e];l.bulkModulus[a]=n.averageBulkModulus(s),l.shearModulus[a]=n.averageShearModulus(s),l.youngsModulus[a]=n.averageYoungsModulus(s),l.poissonRatio[a]=n.averagePoissonRatio(s),l.linearCompressibility[a]=1e3/l.bulkModulus[a]}const c=[];for(let e=0;e<6;e++)c.push(a[e][e]);c.sort(((e,s)=>e-s));const u=50,p=[];for(let e=0;e<u;e++)for(let s=0;s<u;s++){const a=e/u*Math.PI,t=s/u*2*Math.PI,n=Math.sin(a)*Math.cos(t),r=Math.sin(a)*Math.sin(t),i=Math.cos(a);p.push(o.Vec3.create(n,r,i))}let g=1/0,M=-1/0,m=1/0,h=-1/0,y=1/0,f=-1/0,d=1/0,v=-1/0;p.forEach((s=>{try{const a=n.youngsModulus(s);g=Math.min(g,a),M=Math.max(M,a);const t=n.linearCompressibility(s);m=Math.min(m,t),h=Math.max(h,t);try{const e=n.shearModulusMinMax(s);e&&(y=Math.min(y,e.min),f=Math.max(f,e.max))}catch(e){const t=a/2.6;y=Math.min(y,t),f=Math.max(f,t)}try{const e=n.poissonRatioMinMax(s);e&&(d=Math.min(d,e.min),v=Math.max(v,e.max))}catch(e){const t=a/(a/3*2)-1;d=Math.min(d,Math.max(-1,t)),v=Math.max(v,Math.min(.5,t))}}catch(e){postMessage({type:"log",level:1,message:`Warning: Could not calculate property for direction: ${e.message}`})}}));const x={shearModulus:{min:y,max:f,anisotropy:f/y},youngsModulus:{min:g,max:M,anisotropy:M/g},poissonRatio:{min:d,max:v,anisotropy:Math.abs(v/d)},linearCompressibility:{min:m,max:h,anisotropy:h/m}},b=[],k=[],R=n.voigtC,C=n.voigtS;for(let e=0;e<6;e++){const s=[],a=[];for(let t=0;t<6;t++)s.push(R.get(e,t)),a.push(C.get(e,t));b.push(s),k.push(a)}postMessage({type:"analysisResult",success:!0,data:{properties:l,eigenvalues:c,extrema:x,stiffnessMatrix:b,complianceMatrix:k,elasticTensor:n}}),postMessage({type:"log",level:2,message:"Elastic tensor analysis complete"})}catch(a){postMessage({type:"analysisResult",success:!1,error:a.message})}}(n);break;case"generateDirectionalData":await async function(s){try{const{tensorData:a,property:t,plane:n,numPoints:r,isReference:i}=s;let l;postMessage({type:"log",level:2,message:`Generating directional data for ${t} ${n} (ref: ${i})...`}),l=o.Mat6&&o.Mat6.create?o.Mat6.create(6,6):o.Mat.create(6,6);for(let e=0;e<6;e++)for(let s=0;s<6;s++)l.set(e,s,a[e][s]);const c=new o.ElasticTensor(l);if(c.generateDirectionalData)try{const e=c.generateDirectionalData(t,r||180),s=[];for(let a=0;a<e.size();a++){const t=e.get(a);let o=t.x,r=t.y;if("xz"===n){const e=r;r=0,r=e}else if("yz"===n){const e=o;o=r,r=e}s.push({angle:180*t.angle/Math.PI,angleRad:t.angle,value:t.value,valueMin:t.value,valueMax:t.value,x:o,y:r})}return postMessage({type:"directionalDataResult",success:!0,data:s,plane:n,isReference:i||!1}),void postMessage({type:"log",level:2,message:"Directional data generation complete (WASM)"})}catch(e){postMessage({type:"log",level:1,message:`WASM method failed, using fallback: ${e.message}`})}const u=[];for(let s=0;s<=r;s++){const a=s/r*2*Math.PI;let i;i="xy"===n?o.Vec3.create(Math.cos(a),Math.sin(a),0):"xz"===n?o.Vec3.create(Math.cos(a),0,Math.sin(a)):o.Vec3.create(0,Math.cos(a),Math.sin(a));let l=0,p=0,g=0;try{if("youngs"===t)l=c.youngsModulus(i),p=g=l;else if("linear_compressibility"===t)l=c.linearCompressibility(i),p=g=l;else if("shear"===t){const e=c.shearModulusMinMax(i);p=e.min,g=e.max,l=g}else if("poisson"===t){const e=c.poissonRatioMinMax(i);p=e.min,g=e.max,l=g}}catch(e){l=p=g=0}u.push({angle:180*a/Math.PI,angleRad:a,value:l,valueMin:p,valueMax:g})}postMessage({type:"directionalDataResult",success:!0,data:u,plane:n,isReference:i||!1}),postMessage({type:"log",level:2,message:"Directional data generation complete"})}catch(a){postMessage({type:"directionalDataResult",success:!1,error:a.message})}}(n);break;case"generate3DSurfaceData":await async function(s){try{const{tensorData:a,property:t,isReference:n}=s;let r;postMessage({type:"log",level:2,message:`Generating 3D surface data for ${t}...`}),r=o.Mat6&&o.Mat6.create?o.Mat6.create(6,6):o.Mat.create(6,6);for(let e=0;e<6;e++)for(let s=0;s<6;s++)r.set(e,s,a[e][s]);const i=new o.ElasticTensor(r),l=120,c=60,u=[];for(let s=0;s<=l;s++){const a=[];for(let n=0;n<=c;n++){const r=s/l*2*Math.PI,u=n/c*Math.PI,p=Math.sin(u)*Math.cos(r),g=Math.sin(u)*Math.sin(r),M=Math.cos(u),m=o.Vec3.create(p,g,M);let h=0;try{if("youngs"===t)h=i.youngsModulus(m);else if("linear_compressibility"===t)h=i.linearCompressibility(m);else if("shear"===t){const e=i.shearModulusMinMax(m);h=e?e.max:0}else if("poisson"===t){const e=i.poissonRatioMinMax(m);h=e?e.max:0}}catch(e){h=0}a.push(h)}u.push(a)}const p=u.flat(),g=Math.min(...p),M=Math.max(...p);postMessage({type:"3DSurfaceResult",success:!0,data:{surfaceData:u,minValue:g,maxValue:M,property:t,numU:l+1,numV:c+1},isReference:n||!1}),postMessage({type:"log",level:2,message:"3D surface data generation complete"})}catch(a){postMessage({type:"3DSurfaceResult",success:!1,error:a.message})}}(n);break;default:postMessage({type:"error",error:`Unknown message type: ${s}`})}}catch(r){postMessage({type:"error",error:r.message||"Unknown error occurred",stack:r.stack})}}))})();
(()=>{var e,t,s,a,o,r,l={},n={};function i(e){var t=n[e];if(void 0!==t)return t.exports;var s=n[e]={exports:{}};return l[e](s,s.exports,i),s.exports}i.m=l,e="function"==typeof Symbol?Symbol("webpack queues"):"__webpack_queues__",t="function"==typeof Symbol?Symbol("webpack exports"):"__webpack_exports__",s="function"==typeof Symbol?Symbol("webpack error"):"__webpack_error__",a=e=>{e&&e.d<1&&(e.d=1,e.forEach((e=>e.r--)),e.forEach((e=>e.r--?e.r++:e())))},i.a=(o,r,l)=>{var n;l&&((n=[]).d=-1);var i,c,u,g=new Set,p=o.exports,m=new Promise(((e,t)=>{u=t,c=e}));m[t]=p,m[e]=e=>(n&&e(n),g.forEach(e),m.catch((e=>{}))),o.exports=m,r((o=>{var r;i=(o=>o.map((o=>{if(null!==o&&"object"==typeof o){if(o[e])return o;if(o.then){var r=[];r.d=0,o.then((e=>{l[t]=e,a(r)}),(e=>{l[s]=e,a(r)}));var l={};return l[e]=e=>e(r),l}}var n={};return n[e]=e=>{},n[t]=o,n})))(o);var l=()=>i.map((e=>{if(e[s])throw e[s];return e[t]})),c=new Promise((t=>{(r=()=>t(l)).r=0;var s=e=>e!==n&&!g.has(e)&&(g.add(e),e&&!e.d&&(r.r++,e.push(r)));i.map((t=>t[e](s)))}));return r.r?c:l()}),(e=>(e?u(m[s]=e):c(p),a(n)))),n&&n.d<0&&(n.d=0)},r=Object.getPrototypeOf?e=>Object.getPrototypeOf(e):e=>e.__proto__,i.t=function(e,t){if(1&t&&(e=this(e)),8&t)return e;if("object"==typeof e&&e){if(4&t&&e.__esModule)return e;if(16&t&&"function"==typeof e.then)return e}var s=Object.create(null);i.r(s);var a={};o=o||[null,r({}),r([]),r(r)];for(var l=2&t&&e;"object"==typeof l&&!~o.indexOf(l);l=r(l))Object.getOwnPropertyNames(l).forEach((t=>a[t]=()=>e[t]));return a.default=()=>e,i.d(s,a),s},i.d=(e,t)=>{for(var s in t)i.o(t,s)&&!i.o(e,s)&&Object.defineProperty(e,s,{enumerable:!0,get:t[s]})},i.f={},i.e=e=>Promise.all(Object.keys(i.f).reduce(((t,s)=>(i.f[s](e,t),t)),[])),i.u=e=>"assets/js/"+(4602===e?"em-pthread":e)+"."+{796:"d38f8669",2282:"55529801",4602:"d4f855a1",7583:"50e6485b"}[e]+".js",i.miniCssF=e=>{},i.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t),i.r=e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},i.p="/",i.gca=function(e){return e={}[e]||e,i.p+i.u(e)},(()=>{i.b=self.location+"/../../../";var e={842:1};i.f.i=(t,s)=>{e[t]||importScripts(i.p+i.u(t))};var t=self.webpackChunkblog=self.webpackChunkblog||[],s=t.push.bind(t);t.push=t=>{var a=t[0],o=t[1],r=t[2];for(var l in o)i.o(o,l)&&(i.m[l]=o[l]);for(r&&r(i);a.length;)e[a.pop()]=1;s(t)}})();let c=null,u=null,g=null;self.addEventListener("message",(async function(e){const{type:t,data:s}=e.data;try{switch(t){case"init":await async function(){try{postMessage({type:"log",level:2,message:"Initializing OCC in worker..."});try{c=await i.e(796).then(i.bind(i,8415)),postMessage({type:"log",level:2,message:"Loaded OCC package"})}catch(e){return void postMessage({type:"initialized",success:!1,error:`OCC package import failed: ${e.message}. The WASM module contains Node.js-specific imports that don't work in browsers.`})}u=await c.loadOCC();try{g=await i.e(2282).then(i.t.bind(i,2282,23)),postMessage({type:"log",level:2,message:"Optimization module loaded"})}catch(e){postMessage({type:"log",level:3,message:"Optimization module not available"})}u.registerLogCallback&&u.registerLogCallback(((e,t)=>{postMessage({type:"log",level:e,message:t})})),postMessage({type:"initialized",success:!0})}catch(t){postMessage({type:"initialized",success:!1,error:t.message})}}();break;case"calculate":s.optimize?await async function(e){if(!g)throw new Error("Optimization module not loaded");try{e.threads&&e.threads>0&&(u.setNumThreads(e.threads),postMessage({type:"log",level:2,message:`Set number of threads to: ${e.threads}`}));const t=await g.runOptimization(e,c,u),s=t.optimization,a={energy:s.finalEnergy,energyInEV:27.2114*s.finalEnergy,elapsedMs:t.elapsedMs,converged:s.converged,optimization:{trajectory:s,finalXYZ:t.finalXYZ,steps:s.steps,energies:s.energies,gradientNorms:s.gradientNorms},frequencies:t.frequencies};if(t.finalWavefunctionData){const e=t.finalWavefunctionData;a.wavefunctionData=e.wavefunctionData,a.orbitalEnergies=e.orbitalEnergies,a.orbitalOccupations=e.orbitalOccupations,a.properties=e.properties,a.matrices=e.matrices,self.currentMolecule=e.molecule,self.currentCalculation={basis:e.basis,wavefunction:e.wavefunction,method:e.method},postMessage({type:"log",level:2,message:"Final wavefunction data available for orbital visualization and analysis"})}postMessage({type:"result",success:!0,results:a})}catch(t){postMessage({type:"result",success:!1,error:t.message})}}(s):await async function(t){try{const a=performance.now();postMessage({type:"progress",stage:"start",message:"Starting calculation..."}),postMessage({type:"log",level:2,message:"Creating molecule from XYZ data..."});const o=await c.moleculeFromXYZ(t.xyzData);void 0!==t.charge&&0!==t.charge&&(o.setCharge(t.charge),postMessage({type:"log",level:2,message:`Molecular charge set to: ${t.charge}`}));const r=o.numElectrons();if(r%2!=0)throw new Error(`Unrestricted calculations are not supported. Molecule has ${r} electrons (odd number). Please adjust the charge to get an even number of electrons.`);postMessage({type:"log",level:2,message:`Molecule created: ${o.size()} atoms, ${r} electrons (charge: ${t.charge||0})`}),postMessage({type:"progress",stage:"setup",message:`Setting up ${t.method.toUpperCase()} calculation with ${t.basisSet} basis...`});const l=await c.createQMCalculation(o,t.basisSet);t.threads&&t.threads>0&&(u.setNumThreads(t.threads),postMessage({type:"log",level:2,message:`Set number of threads to: ${t.threads}`}));const n=(new c.SCFSettings).setMaxIterations(t.maxIterations).setEnergyTolerance(t.energyTolerance);let i;if(postMessage({type:"progress",stage:"calculation",message:"Running SCF iterations..."}),"hf"===t.method)postMessage({type:"log",level:2,message:"Running Hartree-Fock calculation..."}),i=await l.runHF(n);else if(t.method.startsWith("dft-")){const e=t.method.substring(4);postMessage({type:"log",level:2,message:`Running DFT calculation with ${e} functional...`}),i=await l.runDFT(e,{scfSettings:n})}const g=performance.now()-a;postMessage({type:"progress",stage:"complete",message:"Calculation completed successfully!"});const p={energy:i,energyInEV:27.2114*i,elapsedMs:g,converged:!0};try{const e=await l.calculateProperties(["orbitals","homo","lumo","gap"]);p.properties={homo:e.homo,lumo:e.lumo,gap:e.gap}}catch(e){postMessage({type:"log",level:3,message:`Could not calculate properties: ${e.message}`})}try{const e=l.wavefunction;p.wavefunctionData={numBasisFunctions:l.basis.nbf(),numAtoms:o.size(),nAlpha:e.nAlpha||Math.ceil(o.numElectrons()/2),nBeta:e.nBeta||Math.floor(o.numElectrons()/2),numElectrons:o.numElectrons(),basisSet:t.basisSet,method:t.method};try{postMessage({type:"log",level:2,message:"Generating FCHK file..."});const t=e.exportToString("fchk");if(!(t&&t.length>0))throw new Error("FCHK string is empty or null");p.wavefunctionData.fchk=t,postMessage({type:"log",level:2,message:"FCHK file generated successfully"})}catch(s){postMessage({type:"log",level:3,message:`Could not generate FCHK file: ${s.message}`})}self.currentCalculation=l,self.currentMolecule=o}catch(e){postMessage({type:"log",level:3,message:`Could not store wavefunction data: ${e.message}`})}postMessage({type:"progress",stage:"matrices",message:"Computing matrices..."}),p.matrices={};try{const t=new(c.getModule().HartreeFock)(l.basis),s=l.wavefunction,a=e=>{const t=e.rows(),s=e.cols(),a=[];for(let o=0;o<t;o++){const t=[];for(let a=0;a<s;a++)t.push(e.get(o,a));a.push(t)}return{rows:t,cols:s,data:a}};postMessage({type:"log",level:2,message:"Computing overlap matrix..."});try{const e=t.overlapMatrix();p.matrices.overlap=a(e)}catch(e){postMessage({type:"log",level:3,message:`Could not compute overlap matrix: ${e.message}`})}postMessage({type:"log",level:2,message:"Computing kinetic energy matrix..."});try{const e=t.kineticMatrix();p.matrices.kinetic=a(e)}catch(e){postMessage({type:"log",level:3,message:`Could not compute kinetic matrix: ${e.message}`})}postMessage({type:"log",level:2,message:"Computing nuclear attraction matrix..."});try{const e=t.nuclearAttractionMatrix();p.matrices.nuclear=a(e)}catch(e){postMessage({type:"log",level:3,message:`Could not compute nuclear attraction matrix: ${e.message}`})}postMessage({type:"log",level:2,message:"Computing Fock matrix..."});try{const e=t.fockMatrix(s.molecularOrbitals);p.matrices.fock=a(e)}catch(e){postMessage({type:"log",level:3,message:`Could not compute Fock matrix: ${e.message}`})}postMessage({type:"log",level:2,message:"Extracting density matrix..."});try{const e=s.molecularOrbitals.densityMatrix;p.matrices.density=a(e)}catch(e){postMessage({type:"log",level:3,message:`Could not extract density matrix: ${e.message}`})}postMessage({type:"log",level:2,message:"Extracting MO coefficients..."});try{const e=s.coefficients();p.matrices.coefficients=a(e)}catch(e){postMessage({type:"log",level:3,message:`Could not extract MO coefficients: ${e.message}`})}try{const e=s.orbitalEnergies(),t=[];for(let s=0;s<e.size();s++)t.push(e.get(s));p.orbitalEnergies=t}catch(e){postMessage({type:"log",level:3,message:`Could not extract orbital energies: ${e.message}`})}try{const e=p.orbitalEnergies?p.orbitalEnergies.length:0;if(e>0){const t=[],a=s.nAlpha||Math.ceil(o.numElectrons()/2),r=s.nBeta||Math.floor(o.numElectrons()/2);for(let s=0;s<e;s++)s<Math.min(a,r)?t.push(2):s<Math.max(a,r)?t.push(1):t.push(0);p.orbitalOccupations=t}}catch(e){postMessage({type:"log",level:3,message:`Could not extract orbital occupations: ${e.message}`})}}catch(e){postMessage({type:"log",level:3,message:`Matrix computation failed: ${e.message}`})}postMessage({type:"result",success:!0,results:p})}catch(a){postMessage({type:"result",success:!1,error:a.message})}}(s);break;case"setLogLevel":a=s.level,u&&u.setLogLevel&&(u.setLogLevel(a),postMessage({type:"log",level:2,message:`Log level set to ${a}`}));break;case"computeCube":await async function(e){try{const a=performance.now();if(postMessage({type:"log",level:2,message:`Computing ${e.cubeType} cube for orbital ${e.orbitalIndex||"N/A"}...`}),!self.currentCalculation||!self.currentMolecule)throw new Error("No calculation available. Please run a calculation first.");const o=Math.min(Math.max(e.gridSteps||40,20),60);o!==(e.gridSteps||40)&&postMessage({type:"log",level:2,message:`Grid steps clamped to valid range: ${o}`});const r=self.currentCalculation.wavefunction;if(!r)throw new Error("Wavefunction is not available or not properly initialized");let l,n;switch(postMessage({type:"log",level:2,message:`Using grid: ${o} steps`}),e.cubeType){case"molecular_orbital":if(void 0===e.orbitalIndex||e.orbitalIndex<0)throw new Error("Invalid orbital index provided");const a=self.currentCalculation.basis?.nbf?.()||0;if(e.orbitalIndex>=a)throw new Error(`Orbital index ${e.orbitalIndex} exceeds available orbitals (${a})`);let i=null,c=null,g=null;try{if(!u.VolumeCalculator)throw new Error("VolumeCalculator not available in OCC module");if(i=new u.VolumeCalculator,c=new u.VolumeGenerationParameters,!u.VolumePropertyKind||!u.VolumePropertyKind.ElectronDensity)throw new Error("VolumePropertyKind.ElectronDensity not available");if(postMessage({type:"log",level:2,message:`Setting up MO calculation for orbital ${e.orbitalIndex}`}),i.setWavefunction(r),c.property=u.VolumePropertyKind.ElectronDensity,c.mo_number=e.orbitalIndex,c.setSteps(o,o,o),postMessage({type:"log",level:2,message:`Computing volume for orbital ${e.orbitalIndex}...`}),g=i.computeVolume(c),!g)throw new Error("Volume computation returned null/undefined");if(n={origin:g.getOrigin(),steps:g.getSteps(),nx:g.nx(),ny:g.ny(),nz:g.nz(),basis:g.getBasis()},postMessage({type:"log",level:2,message:`Grid: ${n.nx}x${n.ny}x${n.nz}, origin: [${n.origin[0].toFixed(2)}, ${n.origin[1].toFixed(2)}, ${n.origin[2].toFixed(2)}]`}),l=i.volumeAsCubeString(g),!l||0===l.length)throw new Error("Cube string generation failed or returned empty result")}catch(t){throw postMessage({type:"log",level:3,message:`MO cube computation error: ${t.message}`}),t}finally{try{g&&g.delete(),c&&c.delete(),i&&i.delete()}catch(s){postMessage({type:"log",level:3,message:`Cleanup error: ${s.message}`})}}break;case"electron_density":let p=null,m=null,d=null;try{if(!u.VolumeCalculator)throw new Error("VolumeCalculator not available in OCC module");if(p=new u.VolumeCalculator,m=new u.VolumeGenerationParameters,!u.VolumePropertyKind||!u.VolumePropertyKind.ElectronDensity)throw new Error("VolumePropertyKind.ElectronDensity not available");if(p.setWavefunction(r),m.property=u.VolumePropertyKind.ElectronDensity,m.setSteps(o,o,o),d=p.computeVolume(m),!d)throw new Error("Density volume computation returned null/undefined");if(n={origin:d.getOrigin(),steps:d.getSteps(),nx:d.nx(),ny:d.ny(),nz:d.nz(),basis:d.getBasis()},l=p.volumeAsCubeString(d),!l||0===l.length)throw new Error("Density cube string generation failed or returned empty result")}catch(t){throw postMessage({type:"log",level:3,message:`Density cube computation error: ${t.message}`}),t}finally{try{d&&d.delete(),m&&m.delete(),p&&p.delete()}catch(s){postMessage({type:"log",level:3,message:`Density cleanup error: ${s.message}`})}}break;case"electric_potential":let y=null,f=null,b=null;try{if(!u.VolumeCalculator)throw new Error("VolumeCalculator not available in OCC module");if(y=new u.VolumeCalculator,f=new u.VolumeGenerationParameters,!u.VolumePropertyKind||!u.VolumePropertyKind.ElectricPotential)throw new Error("VolumePropertyKind.ElectricPotential not available");if(y.setWavefunction(r),f.property=u.VolumePropertyKind.ElectricPotential,f.setSteps(o,o,o),f.setBuffer(gridBuffer),b=y.computeVolume(f),!b)throw new Error("ESP volume computation returned null/undefined");if(l=y.volumeAsCubeString(b),!l||0===l.length)throw new Error("ESP cube string generation failed or returned empty result")}catch(t){throw postMessage({type:"log",level:3,message:`ESP cube computation error: ${t.message}`}),t}finally{try{b&&b.delete(),f&&f.delete(),y&&y.delete()}catch(s){postMessage({type:"log",level:3,message:`ESP cleanup error: ${s.message}`})}}break;default:throw new Error(`Unknown cube type: ${e.cubeType}`)}const i=performance.now()-a;postMessage({type:"log",level:2,message:`Cube computation completed in ${i.toFixed(0)}ms`});const c={type:"cubeResult",success:!0,cubeData:l,cubeType:e.cubeType,orbitalIndex:e.orbitalIndex,gridSteps:e.gridSteps,elapsedMs:i};void 0!==n&&(c.gridInfo=n),postMessage(c)}catch(t){postMessage({type:"cubeResult",success:!1,error:t.message,cubeType:e.cubeType,orbitalIndex:e.orbitalIndex})}}(s);break;case"warmup":await async function(){try{postMessage({type:"log",level:2,message:"Warming up WebAssembly module with 8 threads..."}),u&&u.setNumThreads&&(u.setNumThreads(8),postMessage({type:"log",level:2,message:"Set warmup threads to 8"}));const e="2\nH2 molecule\nH  0.0  0.0  0.0\nH  0.0  0.0  0.74",t=await c.moleculeFromXYZ(e),s=await c.createQMCalculation(t,"sto-3g"),a=(new c.SCFSettings).setMaxIterations(5).setEnergyTolerance(1e-4);await s.scf(a),postMessage({type:"log",level:2,message:"WebAssembly module and thread pool warmed up successfully"})}catch(e){postMessage({type:"log",level:1,message:`Warmup failed (this is usually okay): ${e.message}`})}}();break;default:postMessage({type:"error",error:`Unknown message type: ${t}`})}}catch(o){postMessage({type:"error",error:o.message||"Unknown error occurred",stack:o.stack})}var a}))})();
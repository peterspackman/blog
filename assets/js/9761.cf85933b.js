(()=>{var e={},s={};function a(t){var o=s[t];if(void 0!==o)return o.exports;var n=s[t]={exports:{}};return e[t](n,n.exports,a),n.exports}a.m=e,a.d=(e,s)=>{for(var t in s)a.o(s,t)&&!a.o(e,t)&&Object.defineProperty(e,t,{enumerable:!0,get:s[t]})},a.f={},a.e=e=>Promise.all(Object.keys(a.f).reduce(((s,t)=>(a.f[t](e,s),s)),[])),a.u=e=>"assets/js/"+e+".2dfbe399.js",a.miniCssF=e=>{},a.o=(e,s)=>Object.prototype.hasOwnProperty.call(e,s),a.r=e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},a.p="/",a.gca=function(e){return e={}[e]||e,a.p+a.u(e)},(()=>{a.b=self.location+"/../../../";var e={9761:1};a.f.i=(s,t)=>{e[s]||importScripts(a.p+a.u(s))};var s=self.webpackChunkblog=self.webpackChunkblog||[],t=s.push.bind(s);s.push=s=>{var o=s[0],n=s[1],i=s[2];for(var r in n)a.o(n,r)&&(a.m[r]=n[r]);for(i&&i(a);o.length;)e[o.pop()]=1;t(s)}})();let t=null,o=null;self.addEventListener("message",(async function(e){const{type:s,data:n}=e.data;try{switch(s){case"init":await async function(){try{postMessage({type:"log",level:2,message:"Initializing OCC in worker..."});try{t=await a.e(9819).then(a.bind(a,9819)),postMessage({type:"log",level:2,message:"Loaded OCC package"})}catch(e){return void postMessage({type:"initialized",success:!1,error:`OCC package import failed: ${e.message}. The WASM module contains Node.js-specific imports that don't work in browsers.`})}o=await t.loadOCC(),o.registerLogCallback&&o.registerLogCallback(((e,s)=>{postMessage({type:"log",level:e,message:s})})),postMessage({type:"initialized",success:!0})}catch(s){postMessage({type:"initialized",success:!1,error:s.message})}}();break;case"analyzeTensor":await async function(s){try{postMessage({type:"log",level:2,message:"Starting elastic tensor analysis..."});const{tensorData:t}=s;let n;n=o.Mat6&&o.Mat6.create?o.Mat6.create(6,6):o.Mat.create(6,6);for(let e=0;e<6;e++)for(let s=0;s<6;s++)n.set(e,s,t[e][s]);const i=new o.ElasticTensor(n),r=[o.AveragingScheme.VOIGT,o.AveragingScheme.REUSS,o.AveragingScheme.HILL],l=["voigt","reuss","hill"],c={bulkModulus:{},shearModulus:{},youngsModulus:{},poissonRatio:{},linearCompressibility:{}};for(let e=0;e<r.length;e++){const s=r[e],a=l[e];c.bulkModulus[a]=i.averageBulkModulus(s),c.shearModulus[a]=i.averageShearModulus(s),c.youngsModulus[a]=i.averageYoungsModulus(s),c.poissonRatio[a]=i.averagePoissonRatio(s),c.linearCompressibility[a]=1e3/c.bulkModulus[a]}let u=null,g=!0,p=null;try{if(!i.eigenvalues||"function"!=typeof i.eigenvalues)throw new Error("eigenvalues() method not available in ElasticTensor");{const e=i.eigenvalues();if(u=[],e&&e.size&&"function"==typeof e.size)for(let s=0;s<e.size();s++)u.push(e.get(s));else if(e&&void 0!==e.length)for(let s=0;s<e.length;s++)u.push(e[s]);else{if(!Array.isArray(e))throw new Error("Unknown eigenvalue result format");u=[...e]}if(u.sort(((e,s)=>e-s)),g=u.every((e=>e>0)),postMessage({type:"log",level:2,message:`Retrieved ${u.length} eigenvalues: [${u.map((e=>e.toFixed(4))).join(", ")}]`}),!g){const e=u.filter((e=>e<=0)).length;postMessage({type:"log",level:1,message:`Warning: Tensor is not positive definite - ${e} eigenvalue(s) <= 0`})}}}catch(a){p=a.message,u=null,g=!0,postMessage({type:"log",level:1,message:`Could not calculate eigenvalues: ${a.message}`})}const M=50,m=[];for(let e=0;e<M;e++)for(let s=0;s<M;s++){const a=e/M*Math.PI,t=s/M*2*Math.PI,n=Math.sin(a)*Math.cos(t),i=Math.sin(a)*Math.sin(t),r=Math.cos(a);m.push(o.Vec3.create(n,i,r))}let h=1/0,y=-1/0,f=1/0,d=-1/0,v=1/0,x=-1/0,b=1/0,k=-1/0;m.forEach((s=>{try{const a=i.youngsModulus(s);h=Math.min(h,a),y=Math.max(y,a);const t=i.linearCompressibility(s);f=Math.min(f,t),d=Math.max(d,t);try{const e=i.shearModulusMinMax(s);e&&(v=Math.min(v,e.min),x=Math.max(x,e.max))}catch(e){const t=a/2.6;v=Math.min(v,t),x=Math.max(x,t)}try{const e=i.poissonRatioMinMax(s);e&&(b=Math.min(b,e.min),k=Math.max(k,e.max))}catch(e){const t=a/(a/3*2)-1;b=Math.min(b,Math.max(-1,t)),k=Math.max(k,Math.min(.5,t))}}catch(e){postMessage({type:"log",level:1,message:`Warning: Could not calculate property for direction: ${e.message}`})}}));const w={shearModulus:{min:v,max:x,anisotropy:x/v},youngsModulus:{min:h,max:y,anisotropy:y/h},poissonRatio:{min:b,max:k,anisotropy:Math.abs(k/b)},linearCompressibility:{min:f,max:d,anisotropy:d/f}},R=[],C=[],D=i.voigtC,S=i.voigtS;for(let e=0;e<6;e++){const s=[],a=[];for(let t=0;t<6;t++)s.push(D.get(e,t)),a.push(S.get(e,t));R.push(s),C.push(a)}postMessage({type:"analysisResult",success:!0,data:{properties:c,eigenvalues:u,eigenvalueError:p,isPositiveDefinite:g,extrema:w,stiffnessMatrix:R,complianceMatrix:C,elasticTensor:i}}),postMessage({type:"log",level:2,message:"Elastic tensor analysis complete"})}catch(a){postMessage({type:"analysisResult",success:!1,error:a.message})}}(n);break;case"generateDirectionalData":await async function(s){try{const{tensorData:a,property:t,plane:n,numPoints:i,isReference:r}=s;let l;postMessage({type:"log",level:2,message:`Generating directional data for ${t} ${n} (ref: ${r})...`}),l=o.Mat6&&o.Mat6.create?o.Mat6.create(6,6):o.Mat.create(6,6);for(let e=0;e<6;e++)for(let s=0;s<6;s++)l.set(e,s,a[e][s]);const c=new o.ElasticTensor(l);if(c.generateDirectionalData)try{const e=c.generateDirectionalData(t,i||180),s=[];for(let a=0;a<e.size();a++){const t=e.get(a);let o=t.x,i=t.y;if("xz"===n){const e=i;i=0,i=e}else if("yz"===n){const e=o;o=i,i=e}s.push({angle:180*t.angle/Math.PI,angleRad:t.angle,value:t.value,valueMin:t.value,valueMax:t.value,x:o,y:i})}return postMessage({type:"directionalDataResult",success:!0,data:s,plane:n,isReference:r||!1}),void postMessage({type:"log",level:2,message:"Directional data generation complete (WASM)"})}catch(e){postMessage({type:"log",level:1,message:`WASM method failed, using fallback: ${e.message}`})}const u=[];for(let s=0;s<=i;s++){const a=s/i*2*Math.PI;let r;r="xy"===n?o.Vec3.create(Math.cos(a),Math.sin(a),0):"xz"===n?o.Vec3.create(Math.cos(a),0,Math.sin(a)):o.Vec3.create(0,Math.cos(a),Math.sin(a));let l=0,g=0,p=0;try{if("youngs"===t)l=c.youngsModulus(r),g=p=l;else if("linear_compressibility"===t)l=c.linearCompressibility(r),g=p=l;else if("shear"===t){const e=c.shearModulusMinMax(r);g=e.min,p=e.max,l=p}else if("poisson"===t){const e=c.poissonRatioMinMax(r);g=e.min,p=e.max,l=p}}catch(e){l=g=p=0}u.push({angle:180*a/Math.PI,angleRad:a,value:l,valueMin:g,valueMax:p})}postMessage({type:"directionalDataResult",success:!0,data:u,plane:n,isReference:r||!1}),postMessage({type:"log",level:2,message:"Directional data generation complete"})}catch(a){postMessage({type:"directionalDataResult",success:!1,error:a.message})}}(n);break;case"generate3DSurfaceData":await async function(s){try{const{tensorData:a,property:t,isReference:n}=s;let i;postMessage({type:"log",level:2,message:`Generating 3D surface data for ${t}...`}),i=o.Mat6&&o.Mat6.create?o.Mat6.create(6,6):o.Mat.create(6,6);for(let e=0;e<6;e++)for(let s=0;s<6;s++)i.set(e,s,a[e][s]);const r=new o.ElasticTensor(i),l=120,c=60,u=[];for(let s=0;s<=l;s++){const a=[];for(let n=0;n<=c;n++){const i=s/l*2*Math.PI,u=n/c*Math.PI,g=Math.sin(u)*Math.cos(i),p=Math.sin(u)*Math.sin(i),M=Math.cos(u),m=o.Vec3.create(g,p,M);let h=0;try{if("youngs"===t)h=r.youngsModulus(m);else if("linear_compressibility"===t)h=r.linearCompressibility(m);else if("shear"===t){const e=r.shearModulusMinMax(m);h=e?e.max:0}else if("poisson"===t){const e=r.poissonRatioMinMax(m);h=e?e.max:0}}catch(e){h=0}a.push(h)}u.push(a)}const g=u.flat(),p=Math.min(...g),M=Math.max(...g);postMessage({type:"3DSurfaceResult",success:!0,data:{surfaceData:u,minValue:p,maxValue:M,property:t,numU:l+1,numV:c+1},isReference:n||!1}),postMessage({type:"log",level:2,message:"3D surface data generation complete"})}catch(a){postMessage({type:"3DSurfaceResult",success:!1,error:a.message})}}(n);break;default:postMessage({type:"error",error:`Unknown message type: ${s}`})}}catch(i){postMessage({type:"error",error:i.message||"Unknown error occurred",stack:i.stack})}}))})();
(()=>{var e={},t={};function s(o){var a=t[o];if(void 0!==a)return a.exports;var r=t[o]={exports:{}};return e[o](r,r.exports,s),r.exports}s.m=e,s.d=(e,t)=>{for(var o in t)s.o(t,o)&&!s.o(e,o)&&Object.defineProperty(e,o,{enumerable:!0,get:t[o]})},s.f={},s.e=e=>Promise.all(Object.keys(s.f).reduce(((t,o)=>(s.f[o](e,t),t)),[])),s.u=e=>"assets/js/"+e+".631587d1.js",s.miniCssF=e=>{},s.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t),s.r=e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},s.p="/",s.gca=function(e){return e={}[e]||e,s.p+s.u(e)},(()=>{s.b=self.location+"/../../../";var e={842:1};s.f.i=(t,o)=>{e[t]||importScripts(s.p+s.u(t))};var t=self.webpackChunkblog=self.webpackChunkblog||[],o=t.push.bind(t);t.push=t=>{var a=t[0],r=t[1],l=t[2];for(var n in r)s.o(r,n)&&(s.m[n]=r[n]);for(l&&l(s);a.length;)e[a.pop()]=1;o(t)}})();let o=null,a=null;self.addEventListener("message",(async function(e){const{type:t,data:r}=e.data;try{switch(t){case"init":await async function(){try{postMessage({type:"log",level:2,message:"Initializing OCC in worker..."});try{o=await s.e(9819).then(s.bind(s,9819)),postMessage({type:"log",level:2,message:"Loaded OCC package"})}catch(e){return void postMessage({type:"initialized",success:!1,error:`OCC package import failed: ${e.message}. The WASM module contains Node.js-specific imports that don't work in browsers.`})}a=await o.loadOCC(),a.registerLogCallback&&a.registerLogCallback(((e,t)=>{postMessage({type:"log",level:e,message:t})})),postMessage({type:"initialized",success:!0})}catch(t){postMessage({type:"initialized",success:!1,error:t.message})}}();break;case"calculate":await async function(t){try{const a=performance.now();postMessage({type:"progress",stage:"start",message:"Starting calculation..."}),postMessage({type:"log",level:2,message:"Creating molecule from XYZ data..."});const r=await o.moleculeFromXYZ(t.xyzData);postMessage({type:"log",level:2,message:`Molecule created: ${r.size()} atoms`}),postMessage({type:"progress",stage:"setup",message:`Setting up ${t.method.toUpperCase()} calculation with ${t.basisSet} basis...`});const l=await o.createQMCalculation(r,t.basisSet),n=(new o.SCFSettings).setMaxIterations(t.maxIterations).setEnergyTolerance(t.energyTolerance);let i;if(postMessage({type:"progress",stage:"calculation",message:"Running SCF iterations..."}),"hf"===t.method)postMessage({type:"log",level:2,message:"Running Hartree-Fock calculation..."}),i=await l.runHF(n);else if(t.method.startsWith("dft-")){const e=t.method.substring(4);postMessage({type:"log",level:2,message:`Running DFT calculation with ${e} functional...`}),i=await l.runDFT(e,{scfSettings:n})}const c=performance.now()-a;postMessage({type:"progress",stage:"complete",message:"Calculation completed successfully!"});const g={energy:i,energyInEV:27.2114*i,elapsedMs:c,converged:!0};try{const e=await l.calculateProperties(["orbitals","homo","lumo","gap"]);g.properties={homo:e.homo,lumo:e.lumo,gap:e.gap}}catch(e){postMessage({type:"log",level:3,message:`Could not calculate properties: ${e.message}`})}try{const e=l.wavefunction;g.wavefunctionData={numBasisFunctions:l.basis.nbf(),numAtoms:r.size(),nAlpha:e.nAlpha||Math.ceil(r.numElectrons()/2),nBeta:e.nBeta||Math.floor(r.numElectrons()/2),numElectrons:r.numElectrons(),basisSet:t.basisSet,method:t.method};try{postMessage({type:"log",level:2,message:"Generating FCHK file..."});const t=e.exportToString("fchk");if(!(t&&t.length>0))throw new Error("FCHK string is empty or null");g.wavefunctionData.fchk=t,postMessage({type:"log",level:2,message:"FCHK file generated successfully"})}catch(s){postMessage({type:"log",level:3,message:`Could not generate FCHK file: ${s.message}`})}self.currentCalculation=l,self.currentMolecule=r}catch(e){postMessage({type:"log",level:3,message:`Could not store wavefunction data: ${e.message}`})}postMessage({type:"progress",stage:"matrices",message:"Computing matrices..."}),g.matrices={};try{const t=new(o.getModule().HartreeFock)(l.basis),s=l.wavefunction,a=e=>{const t=e.rows(),s=e.cols(),o=[];for(let a=0;a<t;a++){const t=[];for(let o=0;o<s;o++)t.push(e.get(a,o));o.push(t)}return{rows:t,cols:s,data:o}};postMessage({type:"log",level:2,message:"Computing overlap matrix..."});try{const e=t.overlapMatrix();g.matrices.overlap=a(e)}catch(e){postMessage({type:"log",level:3,message:`Could not compute overlap matrix: ${e.message}`})}postMessage({type:"log",level:2,message:"Computing kinetic energy matrix..."});try{const e=t.kineticMatrix();g.matrices.kinetic=a(e)}catch(e){postMessage({type:"log",level:3,message:`Could not compute kinetic matrix: ${e.message}`})}postMessage({type:"log",level:2,message:"Computing nuclear attraction matrix..."});try{const e=t.nuclearAttractionMatrix();g.matrices.nuclear=a(e)}catch(e){postMessage({type:"log",level:3,message:`Could not compute nuclear attraction matrix: ${e.message}`})}postMessage({type:"log",level:2,message:"Computing Fock matrix..."});try{const e=t.fockMatrix(s.molecularOrbitals);g.matrices.fock=a(e)}catch(e){postMessage({type:"log",level:3,message:`Could not compute Fock matrix: ${e.message}`})}postMessage({type:"log",level:2,message:"Extracting density matrix..."});try{const e=s.molecularOrbitals.densityMatrix;g.matrices.density=a(e)}catch(e){postMessage({type:"log",level:3,message:`Could not extract density matrix: ${e.message}`})}postMessage({type:"log",level:2,message:"Extracting MO coefficients..."});try{const e=s.coefficients();g.matrices.coefficients=a(e)}catch(e){postMessage({type:"log",level:3,message:`Could not extract MO coefficients: ${e.message}`})}try{const e=s.orbitalEnergies(),t=[];for(let s=0;s<e.size();s++)t.push(e.get(s));g.orbitalEnergies=t}catch(e){postMessage({type:"log",level:3,message:`Could not extract orbital energies: ${e.message}`})}try{const e=g.orbitalEnergies?g.orbitalEnergies.length:0;if(e>0){const t=[],o=s.nAlpha||Math.ceil(r.numElectrons()/2),a=s.nBeta||Math.floor(r.numElectrons()/2);for(let s=0;s<e;s++)s<Math.min(o,a)?t.push(2):s<Math.max(o,a)?t.push(1):t.push(0);g.orbitalOccupations=t}}catch(e){postMessage({type:"log",level:3,message:`Could not extract orbital occupations: ${e.message}`})}}catch(e){postMessage({type:"log",level:3,message:`Matrix computation failed: ${e.message}`})}postMessage({type:"result",success:!0,results:g})}catch(a){postMessage({type:"result",success:!1,error:a.message})}}(r);break;case"setLogLevel":l=r.level,a&&a.setLogLevel&&(a.setLogLevel(l),postMessage({type:"log",level:2,message:`Log level set to ${l}`}));break;case"computeCube":await async function(e){try{const o=performance.now();if(postMessage({type:"log",level:2,message:`Computing ${e.cubeType} cube for orbital ${e.orbitalIndex||"N/A"}...`}),!self.currentCalculation||!self.currentMolecule)throw new Error("No calculation available. Please run a calculation first.");const r=Math.min(Math.max(e.gridSteps||40,20),60);r!==(e.gridSteps||40)&&postMessage({type:"log",level:2,message:`Grid steps clamped to valid range: ${r}`});const l=self.currentCalculation.wavefunction;if(!l)throw new Error("Wavefunction is not available or not properly initialized");let n,i;switch(postMessage({type:"log",level:2,message:`Using grid: ${r} steps`}),e.cubeType){case"molecular_orbital":if(void 0===e.orbitalIndex||e.orbitalIndex<0)throw new Error("Invalid orbital index provided");const o=self.currentCalculation.basis?.nbf?.()||0;if(e.orbitalIndex>=o)throw new Error(`Orbital index ${e.orbitalIndex} exceeds available orbitals (${o})`);let c=null,g=null,u=null;try{if(!a.VolumeCalculator)throw new Error("VolumeCalculator not available in OCC module");if(c=new a.VolumeCalculator,g=new a.VolumeGenerationParameters,!a.VolumePropertyKind||!a.VolumePropertyKind.ElectronDensity)throw new Error("VolumePropertyKind.ElectronDensity not available");if(postMessage({type:"log",level:2,message:`Setting up MO calculation for orbital ${e.orbitalIndex}`}),c.setWavefunction(l),g.property=a.VolumePropertyKind.ElectronDensity,g.mo_number=e.orbitalIndex,g.setSteps(r,r,r),postMessage({type:"log",level:2,message:`Computing volume for orbital ${e.orbitalIndex}...`}),u=c.computeVolume(g),!u)throw new Error("Volume computation returned null/undefined");if(i={origin:u.getOrigin(),steps:u.getSteps(),nx:u.nx(),ny:u.ny(),nz:u.nz(),basis:u.getBasis()},postMessage({type:"log",level:2,message:`Grid: ${i.nx}x${i.ny}x${i.nz}, origin: [${i.origin[0].toFixed(2)}, ${i.origin[1].toFixed(2)}, ${i.origin[2].toFixed(2)}]`}),n=c.volumeAsCubeString(u),!n||0===n.length)throw new Error("Cube string generation failed or returned empty result")}catch(t){throw postMessage({type:"log",level:3,message:`MO cube computation error: ${t.message}`}),t}finally{try{u&&u.delete(),g&&g.delete(),c&&c.delete()}catch(s){postMessage({type:"log",level:3,message:`Cleanup error: ${s.message}`})}}break;case"electron_density":let p=null,m=null,y=null;try{if(!a.VolumeCalculator)throw new Error("VolumeCalculator not available in OCC module");if(p=new a.VolumeCalculator,m=new a.VolumeGenerationParameters,!a.VolumePropertyKind||!a.VolumePropertyKind.ElectronDensity)throw new Error("VolumePropertyKind.ElectronDensity not available");if(p.setWavefunction(l),m.property=a.VolumePropertyKind.ElectronDensity,m.setSteps(r,r,r),y=p.computeVolume(m),!y)throw new Error("Density volume computation returned null/undefined");if(i={origin:y.getOrigin(),steps:y.getSteps(),nx:y.nx(),ny:y.ny(),nz:y.nz(),basis:y.getBasis()},n=p.volumeAsCubeString(y),!n||0===n.length)throw new Error("Density cube string generation failed or returned empty result")}catch(t){throw postMessage({type:"log",level:3,message:`Density cube computation error: ${t.message}`}),t}finally{try{y&&y.delete(),m&&m.delete(),p&&p.delete()}catch(s){postMessage({type:"log",level:3,message:`Density cleanup error: ${s.message}`})}}break;case"electric_potential":let d=null,f=null,b=null;try{if(!a.VolumeCalculator)throw new Error("VolumeCalculator not available in OCC module");if(d=new a.VolumeCalculator,f=new a.VolumeGenerationParameters,!a.VolumePropertyKind||!a.VolumePropertyKind.ElectricPotential)throw new Error("VolumePropertyKind.ElectricPotential not available");if(d.setWavefunction(l),f.property=a.VolumePropertyKind.ElectricPotential,f.setSteps(r,r,r),f.setBuffer(gridBuffer),b=d.computeVolume(f),!b)throw new Error("ESP volume computation returned null/undefined");if(n=d.volumeAsCubeString(b),!n||0===n.length)throw new Error("ESP cube string generation failed or returned empty result")}catch(t){throw postMessage({type:"log",level:3,message:`ESP cube computation error: ${t.message}`}),t}finally{try{b&&b.delete(),f&&f.delete(),d&&d.delete()}catch(s){postMessage({type:"log",level:3,message:`ESP cleanup error: ${s.message}`})}}break;default:throw new Error(`Unknown cube type: ${e.cubeType}`)}const c=performance.now()-o;postMessage({type:"log",level:2,message:`Cube computation completed in ${c.toFixed(0)}ms`});const g={type:"cubeResult",success:!0,cubeData:n,cubeType:e.cubeType,orbitalIndex:e.orbitalIndex,gridSteps:e.gridSteps,elapsedMs:c};void 0!==i&&(g.gridInfo=i),postMessage(g)}catch(t){postMessage({type:"cubeResult",success:!1,error:t.message,cubeType:e.cubeType,orbitalIndex:e.orbitalIndex})}}(r);break;default:postMessage({type:"error",error:`Unknown message type: ${t}`})}}catch(n){postMessage({type:"error",error:n.message||"Unknown error occurred",stack:n.stack})}var l}))})();
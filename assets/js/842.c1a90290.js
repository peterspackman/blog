(()=>{var e,t,s={},o={};function a(e){var t=o[e];if(void 0!==t)return t.exports;var r=o[e]={exports:{}};return s[e](r,r.exports,a),r.exports}a.m=s,t=Object.getPrototypeOf?e=>Object.getPrototypeOf(e):e=>e.__proto__,a.t=function(s,o){if(1&o&&(s=this(s)),8&o)return s;if("object"==typeof s&&s){if(4&o&&s.__esModule)return s;if(16&o&&"function"==typeof s.then)return s}var r=Object.create(null);a.r(r);var l={};e=e||[null,t({}),t([]),t(t)];for(var n=2&o&&s;"object"==typeof n&&!~e.indexOf(n);n=t(n))Object.getOwnPropertyNames(n).forEach((e=>l[e]=()=>s[e]));return l.default=()=>s,a.d(r,l),r},a.d=(e,t)=>{for(var s in t)a.o(t,s)&&!a.o(e,s)&&Object.defineProperty(e,s,{enumerable:!0,get:t[s]})},a.f={},a.e=e=>Promise.all(Object.keys(a.f).reduce(((t,s)=>(a.f[s](e,t),t)),[])),a.u=e=>"assets/js/"+e+"."+{2282:"55529801",9146:"e7074917"}[e]+".js",a.miniCssF=e=>{},a.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t),a.r=e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},a.p="/",a.gca=function(e){return e={}[e]||e,a.p+a.u(e)},(()=>{a.b=self.location+"/../../../";var e={842:1};a.f.i=(t,s)=>{e[t]||importScripts(a.p+a.u(t))};var t=self.webpackChunkblog=self.webpackChunkblog||[],s=t.push.bind(t);t.push=t=>{var o=t[0],r=t[1],l=t[2];for(var n in r)a.o(r,n)&&(a.m[n]=r[n]);for(l&&l(a);o.length;)e[o.pop()]=1;s(t)}})();let r=null,l=null,n=null;self.addEventListener("message",(async function(e){const{type:t,data:s}=e.data;try{switch(t){case"init":await async function(){try{postMessage({type:"log",level:2,message:"Initializing OCC in worker..."});try{r=await a.e(9146).then(a.bind(a,9146)),postMessage({type:"log",level:2,message:"Loaded OCC package"})}catch(e){return void postMessage({type:"initialized",success:!1,error:`OCC package import failed: ${e.message}. The WASM module contains Node.js-specific imports that don't work in browsers.`})}l=await r.loadOCC();try{n=await a.e(2282).then(a.t.bind(a,2282,23)),postMessage({type:"log",level:2,message:"Optimization module loaded"})}catch(e){postMessage({type:"log",level:3,message:"Optimization module not available"})}l.registerLogCallback&&l.registerLogCallback(((e,t)=>{postMessage({type:"log",level:e,message:t})})),postMessage({type:"initialized",success:!0})}catch(t){postMessage({type:"initialized",success:!1,error:t.message})}}();break;case"calculate":s.optimize?await async function(e){if(!n)throw new Error("Optimization module not loaded");try{const t=await n.runOptimization(e,r,l),s=t.optimization,o={energy:s.finalEnergy,energyInEV:27.2114*s.finalEnergy,elapsedMs:t.elapsedMs,converged:s.converged,optimization:{trajectory:s,finalXYZ:t.finalXYZ,steps:s.steps,energies:s.energies,gradientNorms:s.gradientNorms},frequencies:t.frequencies};if(t.finalWavefunctionData){const e=t.finalWavefunctionData;o.wavefunctionData=e.wavefunctionData,o.orbitalEnergies=e.orbitalEnergies,o.orbitalOccupations=e.orbitalOccupations,o.properties=e.properties,o.matrices=e.matrices,self.currentMolecule=e.molecule,self.currentCalculation={basis:e.basis,wavefunction:e.wavefunction,method:e.method},postMessage({type:"log",level:2,message:"Final wavefunction data available for orbital visualization and analysis"})}postMessage({type:"result",success:!0,results:o})}catch(t){postMessage({type:"result",success:!1,error:t.message})}}(s):await async function(t){try{const o=performance.now();postMessage({type:"progress",stage:"start",message:"Starting calculation..."}),postMessage({type:"log",level:2,message:"Creating molecule from XYZ data..."});const a=await r.moleculeFromXYZ(t.xyzData);void 0!==t.charge&&0!==t.charge&&(a.setCharge(t.charge),postMessage({type:"log",level:2,message:`Molecular charge set to: ${t.charge}`}));const l=a.numElectrons();if(l%2!=0)throw new Error(`Unrestricted calculations are not supported. Molecule has ${l} electrons (odd number). Please adjust the charge to get an even number of electrons.`);postMessage({type:"log",level:2,message:`Molecule created: ${a.size()} atoms, ${l} electrons (charge: ${t.charge||0})`}),postMessage({type:"progress",stage:"setup",message:`Setting up ${t.method.toUpperCase()} calculation with ${t.basisSet} basis...`});const n=await r.createQMCalculation(a,t.basisSet),i=(new r.SCFSettings).setMaxIterations(t.maxIterations).setEnergyTolerance(t.energyTolerance);let c;if(postMessage({type:"progress",stage:"calculation",message:"Running SCF iterations..."}),"hf"===t.method)postMessage({type:"log",level:2,message:"Running Hartree-Fock calculation..."}),c=await n.runHF(i);else if(t.method.startsWith("dft-")){const e=t.method.substring(4);postMessage({type:"log",level:2,message:`Running DFT calculation with ${e} functional...`}),c=await n.runDFT(e,{scfSettings:i})}const g=performance.now()-o;postMessage({type:"progress",stage:"complete",message:"Calculation completed successfully!"});const u={energy:c,energyInEV:27.2114*c,elapsedMs:g,converged:!0};try{const e=await n.calculateProperties(["orbitals","homo","lumo","gap"]);u.properties={homo:e.homo,lumo:e.lumo,gap:e.gap}}catch(e){postMessage({type:"log",level:3,message:`Could not calculate properties: ${e.message}`})}try{const e=n.wavefunction;u.wavefunctionData={numBasisFunctions:n.basis.nbf(),numAtoms:a.size(),nAlpha:e.nAlpha||Math.ceil(a.numElectrons()/2),nBeta:e.nBeta||Math.floor(a.numElectrons()/2),numElectrons:a.numElectrons(),basisSet:t.basisSet,method:t.method};try{postMessage({type:"log",level:2,message:"Generating FCHK file..."});const t=e.exportToString("fchk");if(!(t&&t.length>0))throw new Error("FCHK string is empty or null");u.wavefunctionData.fchk=t,postMessage({type:"log",level:2,message:"FCHK file generated successfully"})}catch(s){postMessage({type:"log",level:3,message:`Could not generate FCHK file: ${s.message}`})}self.currentCalculation=n,self.currentMolecule=a}catch(e){postMessage({type:"log",level:3,message:`Could not store wavefunction data: ${e.message}`})}postMessage({type:"progress",stage:"matrices",message:"Computing matrices..."}),u.matrices={};try{const t=new(r.getModule().HartreeFock)(n.basis),s=n.wavefunction,o=e=>{const t=e.rows(),s=e.cols(),o=[];for(let a=0;a<t;a++){const t=[];for(let o=0;o<s;o++)t.push(e.get(a,o));o.push(t)}return{rows:t,cols:s,data:o}};postMessage({type:"log",level:2,message:"Computing overlap matrix..."});try{const e=t.overlapMatrix();u.matrices.overlap=o(e)}catch(e){postMessage({type:"log",level:3,message:`Could not compute overlap matrix: ${e.message}`})}postMessage({type:"log",level:2,message:"Computing kinetic energy matrix..."});try{const e=t.kineticMatrix();u.matrices.kinetic=o(e)}catch(e){postMessage({type:"log",level:3,message:`Could not compute kinetic matrix: ${e.message}`})}postMessage({type:"log",level:2,message:"Computing nuclear attraction matrix..."});try{const e=t.nuclearAttractionMatrix();u.matrices.nuclear=o(e)}catch(e){postMessage({type:"log",level:3,message:`Could not compute nuclear attraction matrix: ${e.message}`})}postMessage({type:"log",level:2,message:"Computing Fock matrix..."});try{const e=t.fockMatrix(s.molecularOrbitals);u.matrices.fock=o(e)}catch(e){postMessage({type:"log",level:3,message:`Could not compute Fock matrix: ${e.message}`})}postMessage({type:"log",level:2,message:"Extracting density matrix..."});try{const e=s.molecularOrbitals.densityMatrix;u.matrices.density=o(e)}catch(e){postMessage({type:"log",level:3,message:`Could not extract density matrix: ${e.message}`})}postMessage({type:"log",level:2,message:"Extracting MO coefficients..."});try{const e=s.coefficients();u.matrices.coefficients=o(e)}catch(e){postMessage({type:"log",level:3,message:`Could not extract MO coefficients: ${e.message}`})}try{const e=s.orbitalEnergies(),t=[];for(let s=0;s<e.size();s++)t.push(e.get(s));u.orbitalEnergies=t}catch(e){postMessage({type:"log",level:3,message:`Could not extract orbital energies: ${e.message}`})}try{const e=u.orbitalEnergies?u.orbitalEnergies.length:0;if(e>0){const t=[],o=s.nAlpha||Math.ceil(a.numElectrons()/2),r=s.nBeta||Math.floor(a.numElectrons()/2);for(let s=0;s<e;s++)s<Math.min(o,r)?t.push(2):s<Math.max(o,r)?t.push(1):t.push(0);u.orbitalOccupations=t}}catch(e){postMessage({type:"log",level:3,message:`Could not extract orbital occupations: ${e.message}`})}}catch(e){postMessage({type:"log",level:3,message:`Matrix computation failed: ${e.message}`})}postMessage({type:"result",success:!0,results:u})}catch(o){postMessage({type:"result",success:!1,error:o.message})}}(s);break;case"setLogLevel":o=s.level,l&&l.setLogLevel&&(l.setLogLevel(o),postMessage({type:"log",level:2,message:`Log level set to ${o}`}));break;case"computeCube":await async function(e){try{const o=performance.now();if(postMessage({type:"log",level:2,message:`Computing ${e.cubeType} cube for orbital ${e.orbitalIndex||"N/A"}...`}),!self.currentCalculation||!self.currentMolecule)throw new Error("No calculation available. Please run a calculation first.");const a=Math.min(Math.max(e.gridSteps||40,20),60);a!==(e.gridSteps||40)&&postMessage({type:"log",level:2,message:`Grid steps clamped to valid range: ${a}`});const r=self.currentCalculation.wavefunction;if(!r)throw new Error("Wavefunction is not available or not properly initialized");let n,i;switch(postMessage({type:"log",level:2,message:`Using grid: ${a} steps`}),e.cubeType){case"molecular_orbital":if(void 0===e.orbitalIndex||e.orbitalIndex<0)throw new Error("Invalid orbital index provided");const o=self.currentCalculation.basis?.nbf?.()||0;if(e.orbitalIndex>=o)throw new Error(`Orbital index ${e.orbitalIndex} exceeds available orbitals (${o})`);let c=null,g=null,u=null;try{if(!l.VolumeCalculator)throw new Error("VolumeCalculator not available in OCC module");if(c=new l.VolumeCalculator,g=new l.VolumeGenerationParameters,!l.VolumePropertyKind||!l.VolumePropertyKind.ElectronDensity)throw new Error("VolumePropertyKind.ElectronDensity not available");if(postMessage({type:"log",level:2,message:`Setting up MO calculation for orbital ${e.orbitalIndex}`}),c.setWavefunction(r),g.property=l.VolumePropertyKind.ElectronDensity,g.mo_number=e.orbitalIndex,g.setSteps(a,a,a),postMessage({type:"log",level:2,message:`Computing volume for orbital ${e.orbitalIndex}...`}),u=c.computeVolume(g),!u)throw new Error("Volume computation returned null/undefined");if(i={origin:u.getOrigin(),steps:u.getSteps(),nx:u.nx(),ny:u.ny(),nz:u.nz(),basis:u.getBasis()},postMessage({type:"log",level:2,message:`Grid: ${i.nx}x${i.ny}x${i.nz}, origin: [${i.origin[0].toFixed(2)}, ${i.origin[1].toFixed(2)}, ${i.origin[2].toFixed(2)}]`}),n=c.volumeAsCubeString(u),!n||0===n.length)throw new Error("Cube string generation failed or returned empty result")}catch(t){throw postMessage({type:"log",level:3,message:`MO cube computation error: ${t.message}`}),t}finally{try{u&&u.delete(),g&&g.delete(),c&&c.delete()}catch(s){postMessage({type:"log",level:3,message:`Cleanup error: ${s.message}`})}}break;case"electron_density":let p=null,m=null,y=null;try{if(!l.VolumeCalculator)throw new Error("VolumeCalculator not available in OCC module");if(p=new l.VolumeCalculator,m=new l.VolumeGenerationParameters,!l.VolumePropertyKind||!l.VolumePropertyKind.ElectronDensity)throw new Error("VolumePropertyKind.ElectronDensity not available");if(p.setWavefunction(r),m.property=l.VolumePropertyKind.ElectronDensity,m.setSteps(a,a,a),y=p.computeVolume(m),!y)throw new Error("Density volume computation returned null/undefined");if(i={origin:y.getOrigin(),steps:y.getSteps(),nx:y.nx(),ny:y.ny(),nz:y.nz(),basis:y.getBasis()},n=p.volumeAsCubeString(y),!n||0===n.length)throw new Error("Density cube string generation failed or returned empty result")}catch(t){throw postMessage({type:"log",level:3,message:`Density cube computation error: ${t.message}`}),t}finally{try{y&&y.delete(),m&&m.delete(),p&&p.delete()}catch(s){postMessage({type:"log",level:3,message:`Density cleanup error: ${s.message}`})}}break;case"electric_potential":let d=null,f=null,b=null;try{if(!l.VolumeCalculator)throw new Error("VolumeCalculator not available in OCC module");if(d=new l.VolumeCalculator,f=new l.VolumeGenerationParameters,!l.VolumePropertyKind||!l.VolumePropertyKind.ElectricPotential)throw new Error("VolumePropertyKind.ElectricPotential not available");if(d.setWavefunction(r),f.property=l.VolumePropertyKind.ElectricPotential,f.setSteps(a,a,a),f.setBuffer(gridBuffer),b=d.computeVolume(f),!b)throw new Error("ESP volume computation returned null/undefined");if(n=d.volumeAsCubeString(b),!n||0===n.length)throw new Error("ESP cube string generation failed or returned empty result")}catch(t){throw postMessage({type:"log",level:3,message:`ESP cube computation error: ${t.message}`}),t}finally{try{b&&b.delete(),f&&f.delete(),d&&d.delete()}catch(s){postMessage({type:"log",level:3,message:`ESP cleanup error: ${s.message}`})}}break;default:throw new Error(`Unknown cube type: ${e.cubeType}`)}const c=performance.now()-o;postMessage({type:"log",level:2,message:`Cube computation completed in ${c.toFixed(0)}ms`});const g={type:"cubeResult",success:!0,cubeData:n,cubeType:e.cubeType,orbitalIndex:e.orbitalIndex,gridSteps:e.gridSteps,elapsedMs:c};void 0!==i&&(g.gridInfo=i),postMessage(g)}catch(t){postMessage({type:"cubeResult",success:!1,error:t.message,cubeType:e.cubeType,orbitalIndex:e.orbitalIndex})}}(s);break;default:postMessage({type:"error",error:`Unknown message type: ${t}`})}}catch(i){postMessage({type:"error",error:i.message||"Unknown error occurred",stack:i.stack})}var o}))})();
"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([[3825],{3825:(t,n,e)=>{e.d(n,{D0:()=>Z,h4:()=>O});Error;Error;class o extends Error{constructor(t,n){super(t),this.name="DecoderError",this.cause=n,Object.setPrototypeOf(this,o.prototype)}}const i=new Set(["H","He","Li","Be","B","C","N","O","F","Ne","Na","Mg","Al","Si","P","S","Cl","Ar","K","Ca","Sc","Ti","V","Cr","Mn","Fe","Co","Ni","Cu","Zn","Ga","Ge","As","Se","Br","Kr","Rb","Sr","Y","Zr","Nb","Mo","Tc","Ru","Rh","Pd","Ag","Cd","In","Sn","Sb","Te","I","Xe","Cs","Ba","Hf","Ta","W","Re","Os","Ir","Pt","Au","Hg","Tl","Pb","Bi","Po","At","Rn","Fr","Ra","Rf","Db","Sg","Bh","Hs","Mt","Ds","Rg","Cn","Fl","Lv","La","Ce","Pr","Nd","Pm","Sm","Eu","Gd","Tb","Dy","Ho","Er","Tm","Yb","Lu","Ac","Th","Pa","U","Np","Pu","Am","Cm","Bk","Cf","Es","Fm","Md","No","Lr"]),r=new Set(["B","C","N","O","S","P","F","Cl","Br","I"]),s={B:[3],Al:[3],C:[4],Si:[4],N:[3,5],P:[3,5],As:[3,5],O:[2,4],S:[2,4],Se:[2,4],Te:[2,4]},l={B:3,Al:3,C:4,Si:4,N:5,P:5,As:5,O:6,S:6,Se:6,Te:6},a=(new Set(Object.keys(s).map((t=>t.toLowerCase()))),["[C]","[Ring1]","[Ring2]","[Branch1]","[=Branch1]","[#Branch1]","[Branch2]","[=Branch2]","[#Branch2]","[O]","[N]","[=N]","[=C]","[#C]","[S]","[P]"]),c=Object.fromEntries(a.map(((t,n)=>[t,n]))),h=new Map,u=new Map,d=new Map,g=new RegExp("^\\[([=#/\\\\]?)(\\d*)([A-Z][a-z]?)([@]{0,2})((?:[H]\\d)?)((?:[+-]\\d+)?)\\]$");function f(t){let n=h.get(t);if(void 0===n&&(n=S(t),h.set(t,n)),null===n)return null;const[e,o]=n,i=o();return i.bondingCapacity<0?null:[e,i]}function b(t){return u.get(t)||null}function p(t){return d.get(t)||null}function _(t,n,e){0===e&&(t=0);const o=n-(t=Math.min(t,e||0,n));return[t,0===o?null:o]}function B(t,n){if(!(1<=t&&t<=3))throw new Error(`Invalid branch type: ${t}`);if(null===n||n<=1)throw new Error(`Invalid state for branching: ${n}`);const e=Math.min(n-1,t),o=n-e;return[e,0===o?null:o]}function m(t,n){if(null===n||n<=0)throw new Error(`Invalid state for ring: ${n}`);const e=Math.min(t,n),o=n-e;return[e,0===o?null:o]}function C(t){switch(t){case"":case"-":return[1,null];case"=":return[2,null];case"#":return[3,null];case"/":return[1,"/"];case"\\":return[1,"\\"];default:throw new Error(`Unknown bond character: ${t}`)}}function S(t){const n=g.exec(t);if(!n)return null;const[,e,o,s,l,a,c]=n,h=t.slice(1+e.length,-1);if(r.has(h)){const t=()=>new v(s,!1);return[C(e),t]}if(!i.has(s))return null;const u=""===o?null:parseInt(o,10),d=""===l?null:l;let f,b;if(f=""===a?0:parseInt(a.slice(1),10),""===c)b=0;else{const t=parseInt(c.slice(1),10);b="+"===c[0]?t:-t}return[C(e),()=>new v(s,!1,u,d,f,b)]}function w(){const t=["[#C+1]","[#C-1]","[#C]","[#N+1]","[#N]","[#O+1]","[#P+1]","[#P-1]","[#P]","[#S+1]","[#S-1]","[#S]","[=C+1]","[=C-1]","[=C]","[=N+1]","[=N-1]","[=N]","[=O+1]","[=O]","[=P+1]","[=P-1]","[=P]","[=S+1]","[=S-1]","[=S]","[Br]","[C+1]","[C-1]","[C]","[Cl]","[F]","[H]","[I]","[N+1]","[N-1]","[N]","[O+1]","[O-1]","[O]","[P+1]","[P-1]","[P]","[S+1]","[S-1]","[S]"];for(const n of t)h.set(n,S(n))}function R(){for(let t=1;t<=3;t++)for(const n of["","=","#"]){const e=`[${n}Branch${t}]`,[o]=C(n);u.set(e,[o,t])}}function x(){for(let t=1;t<=3;t++){for(const e of["","=","#"]){const n=`[${e}Ring${t}]`,[o,i]=C(e);d.set(n,[o,t,[i,i]])}const n=["-","/","\\"];for(const e of n)for(const o of n){if("-"===e&&"-"===o)continue;const n=`[${e}${o}Ring${t}]`,[,i]=C(e),[,r]=C(o);d.set(n,[1,t,[i,r]])}}}w(),R(),x();const y={H:1,F:1,Cl:1,Br:1,I:1,B:3,"B+1":2,"B-1":4,O:2,"O+1":3,"O-1":1,N:3,"N+1":4,"N-1":2,C:4,"C+1":3,"C-1":3,P:5,"P+1":4,"P-1":6,S:6,"S+1":5,"S-1":5,"?":8},E={default:{...y},octet_rule:{...y,S:2,"S+1":3,"S-1":1,P:3,"P+1":4,"P-1":2},hypervalent:{...y,Cl:7,Br:7,I:7,N:5}};let A={...E.default},$=null;const N=new Map;function O(){if(null!==$)return new Set($);const t=new Set,n={"":1,"=":2,"#":3};for(const[e,o]of Object.entries(A))for(const[i,r]of Object.entries(n)){if(r>o||"?"===e)continue;const n=`[${i}${e}]`;t.add(n)}for(let e=1;e<=3;e++)t.add(`[Ring${e}]`),t.add(`[=Ring${e}]`),t.add(`[Branch${e}]`),t.add(`[=Branch${e}]`),t.add(`[#Branch${e}]`);for(const e of a){const n=e.match(/^\[([=#]?)([A-Z][a-z]?)\]$/);if(n){const[,o,i]=n;("="===o?2:"#"===o?3:1)<=(A[i]??A["?"])&&t.add(e)}else t.add(e)}return $=new Set(t),new Set(t)}function P(t){const n=function(t){const n=new Array(t.length).fill(null),e=t.map((t=>t.length)),o=[];for(let r=0;r<t.length;r++)o.push({degree:e[r],node:r});o.sort(((t,n)=>t.degree-n.degree));let i=0;for(;i<o.length;){const{node:r}=o[i++];if(null!==n[r]||0===e[r])continue;let s=-1,l=1/0;for(const o of t[r])null===n[o]&&e[o]<l&&(s=o,l=e[o]);if(-1!==s){n[r]=s,n[s]=r;for(const n of t[r])e[n]--;for(const n of t[s])e[n]--}}return n}(t),e=new Set;for(let o=0;o<t.length;o++)null===n[o]&&e.add(o);for(;e.size>0;){const o=e.values().next().value;e.delete(o);const i=M(t,o,n);if(null===i)return null;k(n,i),e.delete(i[0]),e.delete(i[i.length-1])}return n}function M(t,n,e){const o=new Set,i=new Array(t.length).fill(null),r=[n];for(o.add(n);r.length>0;){const n=r.shift();for(const s of t[n]){if(o.has(s))continue;o.add(s),i[s]=n;const t=e[s];if(null===t){const t=[s];let n=s;for(;null!==i[n];)n=i[n],t.unshift(n);return t}o.has(t)||(o.add(t),i[t]=s,r.push(t))}}return null}function k(t,n){for(let e=0;e<n.length-1;e++){const o=n[e],i=n[e+1];t[o]=i,t[i]=o}}class L{constructor(t,n){this.index=t,this.token=n}}class v{constructor(t,n,e=null,o=null,i=null,r=0){this.index=null,this._bondingCapacityCache=null,this.element=t,this.isAromatic=n,this.isotope=e,this.chirality=o,this.hCount=i,this.charge=r}get bondingCapacity(){if(null===this._bondingCapacityCache){let t=function(t,n){let e=t;0!==n&&(e+=(n>0?"+":"")+n.toString());const o=e;if(N.has(o))return N.get(o);const i=A[e]??A["?"];return N.set(o,i),i}(this.element,this.charge);t-=null===this.hCount?0:this.hCount,this._bondingCapacityCache=t}return this._bondingCapacityCache}clearBondingCapacityCache(){this._bondingCapacityCache=null}invertChirality(){"@"===this.chirality?this.chirality="@@":"@@"===this.chirality&&(this.chirality="@")}}class F{constructor(t,n,e,o,i){this.src=t,this.dst=n,this.order=e,this.stereo=o,this.ringBond=i}}class I{constructor(t=!1){this._roots=[],this._atoms=[],this._bondDict=new Map,this._adjList=[],this._bondCounts=[],this._ringBondFlags=[],this._delocalSubgraph=new Map,this._attribution=new Map,this._attributable=t}get length(){return this._atoms.length}_bondKey(t,n){return`${t},${n}`}hasBond(t,n){return t>n&&([t,n]=[n,t]),this._bondDict.has(this._bondKey(t,n))}hasOutRingBond(t){return this._ringBondFlags[t]||!1}getAttribution(t){return this._attributable&&this._attribution.has(t)?this._attribution.get(t):null}getRoots(){return[...this._roots]}getAtom(t){return this._atoms[t]}getAtoms(){return[...this._atoms]}getOutDirBonds(t){return[...this._adjList[t]]}getDirBond(t,n){const e=this._bondKey(t,n),o=this._bondDict.get(e);if(!o)throw new Error(`No bond found between ${t} and ${n}`);return o.src===t?o:new F(t,n,o.order,o.stereo,o.ringBond)}getBondCount(t){return this._bondCounts[t]||0}addAtom(t,n=!1){return t.index=this.length,n&&this._roots.push(t.index),this._atoms.push(t),this._adjList.push([]),this._bondCounts.push(0),this._ringBondFlags.push(!1),t.isAromatic&&this._delocalSubgraph.set(t.index,[]),t}addAttribution(t,n){this._attributable&&n&&(this._attribution.has(t)?this._attribution.get(t).push(...n):this._attribution.set(t,[...n]))}addBond(t,n,e,o){if(t>=n)throw new Error(`Source must be less than destination: ${t} >= ${n}`);const i=new F(t,n,e,o,!1);return this._addBondAtLoc(i,-1),this._bondCounts[t]+=e,this._bondCounts[n]+=e,1.5===e&&(this._delocalSubgraph.has(t)||this._delocalSubgraph.set(t,[]),this._delocalSubgraph.has(n)||this._delocalSubgraph.set(n,[]),this._delocalSubgraph.get(t).push(n),this._delocalSubgraph.get(n).push(t)),i}addPlaceholderBond(t){const n=this._adjList[t];return n.push(null),n.length-1}addRingBond(t,n,e,o,i,r=-1,s=-1){const l=new F(t,n,e,o,!0),a=new F(n,t,e,i,!0);this._addBondAtLoc(l,r),this._addBondAtLoc(a,s),this._bondCounts[t]+=e,this._bondCounts[n]+=e,this._ringBondFlags[t]=!0,this._ringBondFlags[n]=!0,1.5===e&&(this._delocalSubgraph.has(t)||this._delocalSubgraph.set(t,[]),this._delocalSubgraph.has(n)||this._delocalSubgraph.set(n,[]),this._delocalSubgraph.get(t).push(n),this._delocalSubgraph.get(n).push(t))}updateBondOrder(t,n,e){if(!(1<=e&&e<=3))throw new Error(`Invalid bond order: ${e}`);t>n&&([t,n]=[n,t]);const o=this._bondDict.get(this._bondKey(t,n));if(!o)throw new Error(`Bond not found: ${t} -> ${n}`);if(e===o.order)return;let i;if(o.ringBond){const e=this._bondDict.get(this._bondKey(n,t));if(!e)throw new Error(`Reverse bond not found: ${n} -> ${t}`);i=[o,e]}else i=[o];const r=i[0].order;for(const s of i)s.order=e;this._bondCounts[t]+=e-r,this._bondCounts[n]+=e-r}_addBondAtLoc(t,n){this._bondDict.set(this._bondKey(t.src,t.dst),t);const e=this._adjList[t.src];-1===n||n===e.length?e.push(t):null===e[n]?e[n]=t:e.splice(n,0,t)}isKekulized(){return 0===this._delocalSubgraph.size}kekulize(){if(this.isKekulized())return!0;const t=this._delocalSubgraph,n=new Set;for(const s of t.keys())this._pruneFromDs(s)||n.add(s);const e=[...n].sort(((t,n)=>t-n)),o=new Map;e.forEach(((t,n)=>o.set(t,n)));const i=Array(n.size).fill(null).map((()=>[]));for(const s of n){const e=o.get(s);for(const r of t.get(s)||[])n.has(r)&&i[e].push(o.get(r))}const r=P(i);if(null===r)return!1;for(const s of t.keys()){for(const n of t.get(s)||[])this.updateBondOrder(s,n,1);s<this._atoms.length&&(this._atoms[s].isAromatic=!1,this._bondCounts[s]=Math.round(this._bondCounts[s]))}for(let s=0;s<r.length;s++){const t=r[s];if(null!==t&&s<t){const n=e[s],o=e[t];this.updateBondOrder(n,o,2)}}return this._delocalSubgraph.clear(),!0}_pruneFromDs(t){if(0===(this._delocalSubgraph.get(t)||[]).length)return!0;if(t>=this._atoms.length)return!0;const n=this._atoms[t],e=s[n.element];if(!e)return!0;const o=l[n.element]||0,i=n.charge,r=n.hCount||0;let a=0,c=0;for(let s=0;s<this._adjList[t].length;s++){const n=this._adjList[t][s];if(n&&n.dst<this._atoms.length){this._atoms[n.dst].isAromatic&&this._delocalSubgraph.has(n.dst)?c++:a+=n.order}}a+=r;const h=o-i-a;let u=!1;for(const s of e){const t=s-a;if(t>=c&&h>=c&&h<=t){u=!0;break}}return!u&&c>0&&("C"===n.element&&2===c&&h>=2||"N"===n.element&&c<=2&&h>=1||("O"===n.element||"S"===n.element)&&c<=2&&h>=2)&&(u=!0),!u}}class D{constructor(){this.nextRingNumber=1,this.ringBondToNumber=new Map}getRingNumber(t,n){const e=`${t}-${n}`,o=`${n}-${t}`;let i=this.ringBondToNumber.get(e)??this.ringBondToNumber.get(o);return void 0===i&&(i=this.nextRingNumber++,this.ringBondToNumber.set(e,i),this.ringBondToNumber.set(o,i)),i}}function j(t,n,e,o,i,s){if(e.has(n))return["",null];e.add(n);const l=t.getAtom(n),a=function(t){if(r.has(t.element)&&0===t.charge&&!t.chirality&&!t.isotope&&(null===t.hCount||0===t.hCount))return t.element;let n="[";null!==t.isotope&&(n+=t.isotope.toString());n+=t.element,t.chirality&&(n+=t.chirality);null!==t.hCount&&t.hCount>0&&(n+="H",t.hCount>1&&(n+=t.hCount.toString()));0!==t.charge&&(t.charge>0?(n+="+",n+=t.charge.toString()):n+=t.charge.toString());return n+="]",n}(l),c=[];if(o){const n=t.getAttribution(l);n&&c.push({token:a,attribution:n})}let h=a;const u=t.getOutDirBonds(n),d=[],g=[];for(const r of u)r.dst!==n&&(r.ringBond?g.push(r):e.has(r.dst)||d.push(r));for(const r of g)if(s){h+=s.getRingNumber(n,r.dst).toString()}for(let r=0;r<d.length;r++){const n=d[r],[i,l]=T(n,o?t.getAttribution(n):null),[a,u]=j(t,n.dst,e,o,n,s);let g=i+a;r<d.length-1&&(g="("+g+")"),h+=g,o&&(l&&c.push(l),u&&c.push(...u))}return[h,o?c:null]}function T(t,n){let e="";switch(t.order){case 1:"/"===t.stereo?e="/":"\\"===t.stereo&&(e="\\");break;case 2:e="=";break;case 3:e="#"}return[e,n?{token:e,attribution:n}:null]}function*H(t){let n=t.indexOf("[");for(;n>=0&&n<t.length;){const e=t.indexOf("]",n+1);if(-1===e)throw new Error("malformed SELFIES string, hanging '[' bracket");const o=t.slice(n,e+1);yield o,n=e+1,"."===t.slice(n,n+1)&&(yield".",n+=1),n=t.indexOf("[",n)}}const K={"[Branch1_1]":"[Branch1]","[Branch1_2]":"[=Branch1]","[Branch1_3]":"[#Branch1]","[Branch2_1]":"[Branch2]","[Branch2_2]":"[=Branch2]","[Branch2_3]":"[#Branch2]","[Branch3_1]":"[Branch3]","[Branch3_2]":"[=Branch3]","[Branch3_3]":"[#Branch3]","[Expl=Ring1]":"[=Ring1]","[Expl#Ring1]":"[#Ring1]","[Expl=Ring2]":"[=Ring2]","[Expl#Ring2]":"[#Ring2]","[Expl=Ring3]":"[=Ring3]","[Expl#Ring3]":"[#Ring3]","[Expl=Ring4]":"[=Ring4]","[Expl#Ring4]":"[#Ring4]","[Expl=Ring5]":"[=Ring5]","[Expl#Ring5]":"[#Ring5]","[Expl=Ring6]":"[=Ring6]","[Expl#Ring6]":"[#Ring6]","[Expl=Ring7]":"[=Ring7]","[Expl#Ring7]":"[#Ring7]","[Expl=Ring8]":"[=Ring8]","[Expl#Ring8]":"[#Ring8]","[Expl=Ring9]":"[=Ring9]","[Expl#Ring9]":"[#Ring9]"};function z(t){if(K[t])return K[t];if(t.endsWith("expl]")){return`[${t.slice(1,-5)}1]`}return t}function Z(t,n){if(!t||"string"!=typeof t)return n?.attribute?["C",[]]:"C";n?.compatible&&console.warn("SELFIES: Using backward compatibility mode is deprecated. Please convert your SELFIES strings to the current format. Behavior may differ from previous major releases.");const e=new I(n?.attribute||!1),o=[];let i=0;for(const r of t.split("."))if(r){i+=U(G(r,n?.compatible),e,t,1/0,0,null,o,n?.attribute?[]:null,i)}return function(t,n){const e=new Array(t.length).fill(0),o=new Map;for(const[i,r,s]of n)if(null!==i.index&&null!==r.index){const t=`${Math.min(i.index,r.index)}-${Math.max(i.index,r.index)}`;o.set(t,(o.get(t)||0)+1)}if(Array.from(o.values()).some((t=>t%2!=0)))return;for(const[i,r,s]of n)if(null!==i.index&&null!==r.index){const n=i.index,o=r.index;if(n===o)continue;const[l,a]=s,c=i.bondingCapacity-t.getBondCount(n),h=r.bondingCapacity-t.getBondCount(o);if(c<=0||h<=0)continue;const u=Math.min(l,c,h);if(t.hasBond(n,o)){const e=t.getDirBond(n,o),i=Math.min(u+e.order,3);t.updateBondOrder(n,o,i)}else t.addRingBond(n,o,u,a,a,e[n],e[o]),e[n]+=1,e[o]+=1}}(e,o),function(t,n=!1){if(0===t.length)return n?["",[]]:"";const e=[],o=[];for(const r of t.getRoots()){const i=new Set,s=new D,[l,a]=j(t,r,i,n,0,s);e.push(l),n&&a&&o.push(...a)}const i=e.join(".");return n?[i,o]:i}(e,n?.attribute||!1)}function*G(t,n){for(let e of H(t))"[nop]"!==e&&(n&&(e=z(e)),yield e)}function U(t,n,e,i,r,s,l,a,c){let h=0,u=r,d=s,g=0;const C=function*(){for(const n of t)yield[g++,n]}();for(;h<i;){let t;try{if(t=C.next(),t.done)break;h++}catch(S){if(S instanceof Error)throw new o(`Malformed SELFIES string: ${S.message}`);throw S}const[i,r]=t.value;if(r.includes("Branch")){const t=b(r);t||Y(e,r);const[o,s]=t;if(null===u||u<=1)continue;{const[t,g]=B(o,u),f=W(C,s);h+=s+U(function*(){for(;;){const t=C.next();if(t.done)break;yield t.value[1]}}(),n,e,f+1,t,d,l,a?[...a,new L(i+c,r)]:null,c),u=g}}else if(r.includes("Ring")){const t=p(r);t||Y(e,r);const[o,i,s]=t;if(0===u||null===u)continue;{const[t,e]=m(o,u),r=[t,s[0]],a=W(C,i);if(h+=i,d&&null!==d.index){const t=Math.max(0,d.index-(a+1)),e=n.getAtom(t);l.push([e,d,r])}u=e}}else if(r.includes("eps"))u=0===u?0:null;else{const t=f(r);t||Y(e,r);const[o,s]=t,[l,h]=o,g=s.bondingCapacity,[b,p]=_(l,g,u);if(0===b){if(0===u){const t=n.addAtom(s,!0);a&&n.addAttribution(t,[...a,new L(i+c,r)])}}else{const t=n.addAtom(s);if(a&&n.addAttribution(t,[...a,new L(i+c,r)]),d&&null!==d.index&&null!==t.index){const e=d.index,o=t.index,s=n.addBond(Math.min(e,o),Math.max(e,o),b,h);a&&n.addAttribution(s,[...a,new L(i+c,r)])}}d=s,u=p??null}}for(;h<i;)try{if(C.next().done)break;h++}catch(S){break}return h}function W(t,n){const e=[];for(let o=0;o<n;o++){const n=t.next();n.done||e.push(n.value[1])}return function(...t){let n=0;const e=t.slice().reverse();for(let o=0;o<e.length;o++){const t=e[o];n+=(c[t]||0)*Math.pow(Object.keys(c).length,o)}return n}(...e)}function Y(t,n){throw new o(`invalid symbol '${n}'\n\tSELFIES: ${t}`)}}}]);
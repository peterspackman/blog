(self.webpackChunkblog=self.webpackChunkblog||[]).push([[2282],{2282:e=>{async function t(e,t,s,o){try{postMessage({type:"progress",stage:"frequencies_start",message:"Computing vibrational frequencies..."});const s=o.AOBasis.load(e.atoms(),t.basisSet);let l,n,r;if("hf"===t.method){const e=new o.HartreeFock(s);l=new o.HartreeFockSCF(e),l.setChargeMultiplicity(t.charge||0,t.multiplicity||1);await l.run();n=l.wavefunction(),r=e.hessianEvaluator()}else if(t.method.startsWith("dft-")){const e=t.method.substring(4),a=new o.DFT(e,s);l=a.scf(o.SpinorbitalKind.Restricted),l.setChargeMultiplicity(t.charge||0,t.multiplicity||1);await l.run();n=l.wavefunction(),r=a.hessianEvaluator()}r.setStepSize(t.hessianStepSize||.005),r.setUseAcousticSumRule(!0),postMessage({type:"log",level:2,message:`Computing Hessian with step size ${r.stepSize()} Bohr...`});const i=r.compute(n);postMessage({type:"log",level:2,message:`Hessian computed: ${i.rows()}x${i.cols()}`});const c=o.computeVibrationalModesFromMolecule(i,e,!1),g=c.getAllFrequencies(),m=[];for(let e=0;e<g.size();e++)m.push(g.get(e));let p=[];try{const e=c.normalModes;if(e){const t=e.rows(),s=e.cols();postMessage({type:"log",level:2,message:`Normal modes matrix: ${t}x${s}`});for(let o=0;o<s;o++){const s=[];for(let a=0;a<t;a++)s.push(e.get(a,o));p.push(s)}postMessage({type:"log",level:2,message:`Extracted ${p.length} normal mode vectors`})}else postMessage({type:"log",level:3,message:"Normal modes matrix is null or undefined"})}catch(a){postMessage({type:"log",level:3,message:`Could not extract normal mode vectors: ${a.message}`})}const u=c.summaryString();return postMessage({type:"log",level:2,message:`Found ${m.length} vibrational modes`}),{frequencies:m,normalModes:p,nModes:c.nModes(),nAtoms:c.nAtoms(),summary:u}}catch(a){return postMessage({type:"log",level:4,message:`Frequency calculation error: ${a.message}`}),null}}e.exports&&(e.exports={runOptimization:async function(e,s,o){const a=performance.now(),l={energies:[],gradientNorms:[],geometries:[],converged:!1,steps:0,finalEnergy:null,finalMolecule:null};try{postMessage({type:"progress",stage:"optimization_start",message:"Starting geometry optimization..."});const i=await s.moleculeFromXYZ(e.xyzData);void 0!==e.charge&&0!==e.charge&&(i.setCharge(e.charge),postMessage({type:"log",level:2,message:`Molecular charge set to: ${e.charge}`}));const c=i.numElectrons();if(c%2!=0)throw new Error(`Unrestricted calculations are not supported. Molecule has ${c} electrons (odd number). Please adjust the charge to get an even number of electrons.`);postMessage({type:"log",level:2,message:`Initial molecule: ${i.size()} atoms, ${c} electrons (charge: ${e.charge||0})`});const g=new o.ConvergenceCriteria;g.gradientMax=e.optGradientMax||1e-4,g.gradientRms=e.optGradientRms||1e-5,g.stepMax=e.optStepMax||.001,g.stepRms=e.optStepRms||1e-4,postMessage({type:"log",level:2,message:`Optimization criteria: gradMax=${g.gradientMax}, gradRms=${g.gradientRms}`});const m=new o.BernyOptimizer(i,g),p=e.optMaxSteps||25;let u=!1;for(let t=0;t<p;t++){postMessage({type:"progress",stage:"optimization_step",message:`Optimization step ${t+1}/${p}...`,step:t+1,maxSteps:p});const s=m.getNextGeometry(),a=o.moleculeToXYZ(s);l.geometries.push(a);const r=o.AOBasis.load(s.atoms(),e.basisSet);let i,c,g,h;if("hf"===e.method){const t=new o.HartreeFock(r);c=new o.HartreeFockSCF(t),c.setChargeMultiplicity(e.charge||0,e.multiplicity||1),g=await c.run();const s=c.wavefunction();h=t.computeGradient(s.molecularOrbitals),i=t}else if(e.method.startsWith("dft-")){const t=e.method.substring(4),s=new o.DFT(t,r);c=s.scf(o.SpinorbitalKind.Restricted),c.setChargeMultiplicity(e.charge||0,e.multiplicity||1),g=await c.run();const a=c.wavefunction();h=s.computeGradient(a.molecularOrbitals),i=s}l.energies.push(g);let f=0;try{f=Math.sqrt(h.squaredNorm())}catch(n){let e=0;const t=h.rows(),s=h.cols();for(let o=0;o<t;o++)for(let t=0;t<s;t++){const s=h.get(o,t);e+=s*s}f=Math.sqrt(e)}if(l.gradientNorms.push(f),postMessage({type:"log",level:2,message:`Step ${t+1}: E = ${g.toFixed(8)} Ha, |grad| = ${f.toFixed(6)}`}),m.update(g,h),m.step()){u=!0,l.converged=!0,l.steps=t+1,postMessage({type:"log",level:2,message:`Optimization converged in ${t+1} steps!`});break}}l.finalMolecule=m.getNextGeometry(),l.finalEnergy=m.currentEnergy(),void 0!==e.charge&&0!==e.charge&&l.finalMolecule.setCharge(e.charge);const h=l.finalMolecule.numElectrons();h%2!=0&&postMessage({type:"log",level:3,message:`Warning: Final molecule has ${h} electrons (odd number). This may cause issues with frequency calculations.`});const f=o.moleculeToXYZ(l.finalMolecule);let d=null;try{postMessage({type:"log",level:2,message:"Computing final wavefunction for optimized geometry..."}),d=await async function(e,t,s,o){try{const s=o.AOBasis.load(e.atoms(),t.basisSet);let r,i,c;if("hf"===t.method){const e=new o.HartreeFock(s);i=new o.HartreeFockSCF(e),i.setChargeMultiplicity(t.charge||0,t.multiplicity||1),await i.run(),c=i.wavefunction(),r=e}else if(t.method.startsWith("dft-")){const e=t.method.substring(4),a=new o.DFT(e,s);i=a.scf(o.SpinorbitalKind.Restricted),i.setChargeMultiplicity(t.charge||0,t.multiplicity||1),await i.run(),c=i.wavefunction(),r=a}const g={numBasisFunctions:s.nbf(),numAtoms:e.size(),nAlpha:c.nAlpha||Math.ceil(e.numElectrons()/2),nBeta:c.nBeta||Math.floor(e.numElectrons()/2),numElectrons:e.numElectrons(),basisSet:t.basisSet,method:t.method};let m=[],p=[];try{const t=c.orbitalEnergies();for(let e=0;e<t.size();e++)m.push(t.get(e));const s=m.length;if(s>0){const t=c.nAlpha||Math.ceil(e.numElectrons()/2),o=c.nBeta||Math.floor(e.numElectrons()/2);for(let e=0;e<s;e++)e<Math.min(t,o)?p.push(2):e<Math.max(t,o)?p.push(1):p.push(0)}}catch(a){postMessage({type:"log",level:3,message:`Could not extract orbital data: ${a.message}`})}try{const e=c.exportToString("fchk");e&&e.length>0&&(g.fchk=e)}catch(l){postMessage({type:"log",level:3,message:`Could not generate FCHK file for optimized geometry: ${l.message}`})}let u=null;try{if(m.length>0&&p.length>0){let e=-1,t=-1;for(let s=0;s<p.length;s++)if(p[s]>0)e=s;else if(-1===t&&0===p[s]){t=s;break}if(e>=0){const s=m[e];if(u={homo:s},t>=0){const e=m[t];u.lumo=e,u.gap=e-s}}}}catch(a){postMessage({type:"log",level:3,message:`Could not calculate molecular properties: ${a.message}`})}let h={};try{const e=e=>{const t=e.rows(),s=e.cols(),o=[];for(let a=0;a<t;a++){const t=[];for(let o=0;o<s;o++)t.push(e.get(a,o));o.push(t)}return{rows:t,cols:s,data:o}};try{const t=r.overlapMatrix();h.overlap=e(t)}catch(n){postMessage({type:"log",level:3,message:`Could not compute overlap matrix: ${n.message}`})}try{const t=r.kineticMatrix();h.kinetic=e(t)}catch(n){postMessage({type:"log",level:3,message:`Could not compute kinetic matrix: ${n.message}`})}try{const t=r.nuclearAttractionMatrix();h.nuclear=e(t)}catch(n){postMessage({type:"log",level:3,message:`Could not compute nuclear attraction matrix: ${n.message}`})}try{const t=r.fockMatrix(c.molecularOrbitals);h.fock=e(t)}catch(n){postMessage({type:"log",level:3,message:`Could not compute Fock matrix: ${n.message}`})}try{const t=c.molecularOrbitals.densityMatrix;h.density=e(t)}catch(n){postMessage({type:"log",level:3,message:`Could not compute density matrix: ${n.message}`})}try{const t=c.coefficients();h.coefficients=e(t)}catch(n){postMessage({type:"log",level:3,message:`Could not extract MO coefficients: ${n.message}`})}}catch(a){postMessage({type:"log",level:3,message:`Matrix computation failed: ${a.message}`})}return{wavefunctionData:g,orbitalEnergies:m,orbitalOccupations:p,properties:u,matrices:h,molecule:e,basis:s,wavefunction:c,method:r}}catch(a){throw postMessage({type:"log",level:4,message:`Final wavefunction calculation error: ${a.message}`}),a}}(l.finalMolecule,e,0,o)}catch(r){postMessage({type:"log",level:3,message:`Warning: Could not compute final wavefunction: ${r.message}`})}let y=null;return e.computeFrequencies&&u&&(y=await t(l.finalMolecule,e,0,o)),{success:!0,optimization:l,finalXYZ:f,finalWavefunctionData:d,frequencies:y,elapsedMs:performance.now()-a}}catch(r){throw postMessage({type:"log",level:4,message:`Optimization error: ${r.message}`}),r}},computeFrequencies:t})}}]);